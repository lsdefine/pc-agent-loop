commit 9b20ca82972ec66622193846801630fd356ce231
Author: Liang Jiaqing <l.j.q.light@gmail.com>
Date:   Fri Jan 16 23:50:19 2026 +0800

    fix: restore files removed by mistake and keep zip ignored

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..4b399e9
--- /dev/null
+++ b/README.md
@@ -0,0 +1,52 @@
+# pc-agent-loop
+
+pc-agent-loop æ˜¯ä¸€ä¸ª**æè‡´ç®€çº¦**çš„ PC çº§è‡ªä¸» AI Agent æ¡†æ¶ã€‚å®ƒé€šè¿‡ä¸åˆ° 100 è¡Œçš„æ ¸å¿ƒä»£ç å’Œçº¦ 200 è¡Œçš„å·¥å…·å®ç°ï¼Œæ„ç­‘äº†æŠŠæ•´ä¸ªpcç»™å®ƒï¼ˆæµè§ˆå™¨ã€ç»ˆç«¯ã€æ–‡ä»¶ç³»ç»Ÿï¼‰çš„ç‰©ç†çº§è‡ªåŠ¨åŒ–èƒ½åŠ›ã€‚
+
+## ğŸš€ æ ¸å¿ƒç‰¹æ€§
+
+- **æç®€è®¾è®¡**: ä»…ç”± **7 ä¸ªåŸºæœ¬å·¥å…·** å’Œä¸€ä¸ªé«˜æ•ˆçš„ **Agentic Loop** æ„æˆï¼Œæ‹’ç»è¿‡åº¦è®¾è®¡ã€‚
+- **è‡ªä¸»ä»£ç æ‰§è¡Œ (Code Execution)**: èƒ½å¤Ÿæ ¹æ®ä»»åŠ¡éœ€æ±‚è‡ªä¸»ç¼–å†™å¹¶è¿è¡Œ Python æˆ– PowerShell è„šæœ¬ï¼Œç›´æ¥æ“æ§ç³»ç»Ÿèµ„æºã€‚
+- **æ·±åº¦ Web è‡ªåŠ¨åŒ– (Advanced Web Automation)**: 
+    - **è¯­ä¹‰åŒ–æ‰«æ**: è‡ªåŠ¨æ¸…æ´— HTML å†…å®¹ï¼Œå°†å¤æ‚çš„ DOM è½¬åŒ–ä¸º AI æ˜“è¯»çš„ç»“æ„ã€‚
+    - **JS æ³¨å…¥æ‰§è¡Œ**: åœ¨æµè§ˆå™¨ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œè‡ªå®šä¹‰ JavaScriptï¼Œå®ç°ç²¾å‡†ç‚¹å‡»ã€æ»šåŠ¨æˆ–æ•°æ®æŠ“å–ã€‚
+    - **TMWebDriver**: æ”¯æŒé€šè¿‡ Tampermonkey å®ç°çš„æŒä¹…åŒ–ä¼šè¯é©±åŠ¨ã€‚
+- **ç²¾å‡†æ–‡ä»¶ç¼–è¾‘ (Smart File Patching)**: å¹¶éç›²ç›®è¦†ç›–ï¼Œè€Œæ˜¯æ”¯æŒé€šè¿‡ `file_patch` ä»¥ä»£ç å—åŒ¹é…æ–¹å¼è¿›è¡Œç²¾ç¡®ä¿®æ”¹ã€‚
+- **äººæœºåä½œæ¨¡å¼ (Human-in-the-loop)**: åœ¨é‡åˆ°éªŒè¯ç ã€å…³é”®æƒé™æˆ–æ¨¡ç³Šå†³ç­–æ—¶ï¼Œä¸»åŠ¨è¯·æ±‚ç”¨æˆ·ä»‹å…¥ã€‚
+
+## ğŸ“‚ é¡¹ç›®ç»“æ„
+
+- `agent_loop.py`: **æ ¸å¿ƒå¼•æ“**ï¼Œè´Ÿè´£â€œæ„ŸçŸ¥-æ€è€ƒ-è¡ŒåŠ¨â€çš„è‡ªä¸»å¾ªç¯é€»è¾‘ã€‚
+- `ga.py`: **å·¥å…·ç®±**ï¼Œå®šä¹‰äº† 7 å¤§æ ¸å¿ƒåŸå­å·¥å…·çš„å…·ä½“å®ç°ã€‚
+- `agentapp.py`: åŸºäº Streamlit æ„å»ºçš„è½»é‡åŒ–äº¤äº’å¼ Web ç•Œé¢ã€‚
+- `sidercall.py`: LLM é€šä¿¡å±‚ï¼Œæ”¯æŒæµå¼è¾“å‡ºä¸ API è°ƒç”¨ã€‚
+- `TMWebDriver.py`: æµè§ˆå™¨é©±åŠ¨æ¨¡å—ï¼ˆéœ€é…åˆ Tampermonkey è„šæœ¬ä½¿ç”¨ï¼‰ã€‚
+
+## ğŸ› ï¸ å¿«é€Ÿå¼€å§‹
+
+### 1. ç¯å¢ƒå‡†å¤‡
+- å®‰è£… Python 3.8+ã€‚
+- ï¼ˆå¯é€‰ï¼‰è‹¥éœ€ç½‘é¡µè‡ªåŠ¨åŒ–ï¼Œè¯·åœ¨æµè§ˆå™¨ä¸­å®‰è£… **Tampermonkey** æ’ä»¶å¹¶å¯¼å…¥æœ¬é¡¹ç›®æä¾›çš„å¯¹åº”è„šæœ¬ã€‚
+
+### 2. å®‰è£…ä¾èµ–
+ç¼ºå•¥è£…å•¥
+
+### 3. å¯åŠ¨åº”ç”¨
+åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹æ‰§è¡Œï¼š
+```bash
+python launch.pyw
+```
+
+## ğŸ§© 7 å¤§æ ¸å¿ƒå·¥å…·
+
+Agent ä»…ä¾é ä»¥ä¸‹ 7 ä¸ªåŸå­å·¥å…·çš„ç»„åˆæ¥å®Œæˆå¤æ‚ä»»åŠ¡ï¼š
+
+1.  **`code_run`**: é’ˆå¯¹ Windows ä¼˜åŒ–çš„åŒæ¨¡æ€ä»£ç æ‰§è¡Œå™¨ï¼ˆPython/PowerShellï¼‰ã€‚
+2.  **`web_scan`**: è·å–ç½‘é¡µæ¸…æ´—åçš„è¯­ä¹‰åŒ– HTML ç»“æ„ï¼Œæ”¯æŒå¤šæ ‡ç­¾ç®¡ç†ã€‚
+3.  **`web_execute_js`**: ç½‘é¡µ JS è„šæœ¬æ³¨å…¥ï¼Œæ”¯æŒå°†ç»“æœå­˜ç›˜åˆ†æã€‚
+4.  **`file_read`**: åˆ†é¡µå¼æ–‡ä»¶è¯»å–ï¼Œæ”¯æŒè¡Œå·å®šä½ã€‚
+5.  **`file_write`**: æ–‡ä»¶å…¨é‡å†™å…¥æˆ–è¿½åŠ ã€‚
+6.  **`file_patch`**: åŸºäºæºç å—åŒ¹é…çš„ç²¾å‡†å±€éƒ¨ä¿®æ”¹ï¼Œç¡®ä¿ç¼©è¿›ä¸€è‡´æ€§ã€‚
+7.  **`ask_user`**: å…³é”®èŠ‚ç‚¹è¯·æ±‚äººç±»å¹²é¢„ã€‚
+
+---
+**âš ï¸ è­¦å‘Š**: æœ¬ Agent å…·å¤‡æ‰§è¡Œæœ¬åœ°ä»£ç å’Œæ§åˆ¶æ“ä½œç³»ç»Ÿçš„ç‰©ç†æƒé™ã€‚è¯·åŠ¡å¿…åœ¨å—ä¿¡ä»»çš„ç¯å¢ƒä¸­è¿è¡Œï¼Œå¹¶åœ¨è¿è¡Œå‰ä»”ç»†æ£€æŸ¥ Agent çš„æ‰§è¡Œæ„å›¾ã€‚
\ No newline at end of file
diff --git a/TMWebDriver.py b/TMWebDriver.py
new file mode 100644
index 0000000..0f58e79
--- /dev/null
+++ b/TMWebDriver.py
@@ -0,0 +1,285 @@
+import json, threading, time, uuid, queue, socket, requests
+from typing import Dict, Any, Optional, List  
+from simple_websocket_server import WebSocketServer, WebSocket  
+from bs4 import BeautifulSoup  
+import bottle, random
+from bottle import route, template, request, response
+
+class Session:
+    def __init__(self, session_id, info, client=None):
+        self.id = session_id
+        self.info = info
+        self.connect_at = time.time()
+        self.disconnect_at = None
+        self.type = info.get('type', 'ws')
+        self.ws_client = client if self.type == 'ws' else None
+        self.http_queue = client if self.type == 'http' else None
+    @property
+    def url(self): return self.info.get('url', '')
+    def is_active(self):
+        return self.disconnect_at is None
+    def reconnect(self, client, info):
+        self.info = info
+        self.type = info.get('type', 'ws')
+        if self.type == 'ws':
+            self.ws_client = client
+            self.http_queue = None
+        elif self.type == 'http':
+            self.http_queue = client
+        self.connect_at = time.time()
+        self.disconnect_at = None
+    def mark_disconnected(self):
+        self.disconnect_at = time.time()
+
+
+class TMWebDriver:  
+    def __init__(self, host: str = 'localhost', port: int = 18765):  
+        self.host = host  
+        self.port = port  
+        self.sessions = {}
+        self.results = {}
+
+        self.default_session_id = None  
+        self.latest_session_id = None  
+        self.last_cmd_time = 0
+        self.is_remote = socket.socket().connect_ex((host, port+1)) == 0
+        if not self.is_remote:  
+            self.start_ws_server()  
+            self.start_http_server()
+        else:
+            self.remote = f'http://{self.host}:{self.port+1}/link'
+
+    def start_http_server(self):
+        self.app = app = bottle.Bottle()
+
+        @app.route('/api/longpoll', method=['GET', 'POST'])
+        def long_poll():
+            data = request.json
+            session_id = data.get('sessionId')  
+            session_info = {'url': data.get('url'), 'title': data.get('title', ''), 'type': 'http'}  
+            if session_id not in self.sessions: 
+                session = Session(session_id, session_info, queue.Queue())
+                print(f"Browser http connected: {session.url} (Session: {session_id})")  
+                self.sessions[session_id] = session
+            session = self.sessions[session_id]
+            if session.type == 'http': msgQ = session.http_queue
+            else: return json.dumps({"id": "", "ret": "use ws"})
+            try: return msgQ.get(timeout=5)
+            except queue.Empty: return json.dumps({"id": "", "ret": "next long-poll"})
+
+        @app.route('/api/result', method=['GET','POST'])
+        def result():
+            data = request.json
+            if data.get('type') == 'result':  
+                self.results[data.get('id')] = {'success': True, 'data': data.get('result'), 'newTabs': data.get('newTabs', [])}  
+            elif data.get('type') == 'error':  
+                self.results[data.get('id')] = {'success': False, 'data': data.get('error')}  
+            return 'ok'
+
+        @app.route('/link', method=['GET','POST'])
+        def link():
+            data = request.json
+            if data.get('cmd') == 'get_all_sessions': return json.dumps({'r': self.get_all_sessions()}, ensure_ascii=False)  
+            if data.get('cmd') == 'find_session': 
+                url_pattern = data.get('url_pattern', '')
+                return json.dumps({'r': self.find_session(url_pattern)}, ensure_ascii=False)
+            if data.get('cmd') == 'execute_js':
+                session_id = data.get('sessionId')
+                code = data.get('code')
+                timeout = float(data.get('timeout', 10.0))
+                auto_switch_newtab = data.get('auto_switch_newtab', False)
+                try:
+                    result = self.execute_js(code, timeout=timeout, session_id=session_id, auto_switch_newtab=auto_switch_newtab)
+                    newTabs = result.get('newTabs', []) if isinstance(result, dict) else []
+                    return json.dumps({'result': result, 'newTabs': newTabs}, ensure_ascii=False)
+                except Exception as e:
+                    return json.dumps({'error': str(e)}, ensure_ascii=False)
+            return 'ok'
+
+        def run(): 
+            import asyncio
+            loop = asyncio.new_event_loop()
+            asyncio.set_event_loop(loop)
+            bottle.run(app, host=self.host, port=self.port+1, server='tornado')
+
+        http_thread = threading.Thread(target=run)  
+        http_thread.daemon = True  
+        http_thread.start()  
+
+    def clean_sessions(self):
+        sids = list(self.sessions.keys())
+        for sid in sids:
+            session = self.sessions[sid]
+            if not session.is_active() and time.time() - session.disconnect_at > 600:
+                del self.sessions[sid]
+    
+    def start_ws_server(self) -> None:  
+        driver = self  
+        class JSExecutor(WebSocket):  
+            def handle(self) -> None:  
+                try:  
+                    data = json.loads(self.data)  
+                    if data.get('type') == 'ready':  
+                        session_id = data.get('sessionId')  
+                        session_info = {'url': data.get('url'), 'title': data.get('title', ''),
+                            'connected_at': time.time(), 'type': 'ws'}  
+                        driver._register_client(session_id, self, session_info)  
+                    elif data.get('type') in 'result':  
+                        driver.results[data.get('id')] = {'success': True, 'data': data.get('result'), 'newTabs': data.get('newTabs', [])}  
+                    elif data.get('type') == 'error':  
+                        driver.results[data.get('id')] = {'success': False, 'data': data.get('error')}  
+                except Exception as e:  
+                    print(f"Error handling message: {e}")  
+                    if hasattr(self, 'data'): print(self.data)  
+            def connected(self): (f"New connection from {self.address}")  
+            def handle_close(self): driver._unregister_client(self)  
+        
+        self.server = WebSocketServer(self.host, self.port, JSExecutor)  
+        server_thread = threading.Thread(target=self.server.serve_forever)  
+        server_thread.daemon = True  
+        server_thread.start()  
+        print(f"WebSocket server running on ws://{self.host}:{self.port}")  
+    
+    def _register_client(self, session_id: str, client: WebSocket, session_info) -> None:  
+        is_new_session = session_id not in self.sessions
+
+        if is_new_session:
+            session = Session(session_id, session_info, client)
+            self.sessions[session_id] = session            
+            print(f"New tab connected: {session.url} (Session: {session_id})")  
+        else:
+            session = self.sessions[session_id]
+            session.reconnect(client, session_info)
+            print(f"Tab reconnected: {session.url} (Session: {session_id})")  
+
+        self.latest_session_id = session_id
+        if self.default_session_id is None: 
+            self.default_session_id = session_id  
+        elif is_new_session:  
+            if time.time() - self.last_cmd_time < 5.0:  
+                print(f"æ£€æµ‹åˆ°è„šæœ¬è§¦å‘çš„æ–°çª—å£ï¼Œè‡ªåŠ¨åˆ‡æ¢ç„¦ç‚¹: {session_id}")
+                self.default_session_id = session_id
+
+    
+    def _unregister_client(self, client: WebSocket) -> None:  
+        for session in self.sessions.values():
+            if session.ws_client == client:
+                session.mark_disconnected()
+                break  
+    
+    def execute_js(self, code, timeout=10.0, session_id=None, auto_switch_newtab=False) -> Any:  
+        if session_id is None: session_id = self.default_session_id  
+        if self.is_remote:
+            print('remote_execute_js')
+            response = self._remote_cmd({"cmd": "execute_js", "sessionId": session_id, 
+                                         "code": code, "timeout": str(timeout), 
+                                         "auto_switch_newtab": auto_switch_newtab})
+            if response.get('error'): raise Exception(response['error'])
+            if auto_switch_newtab and 'newTabs' in response:
+                newtabs = response.get('newTabs', [])
+                if len(newtabs) > 0:
+                    new_session_id = newtabs[0]['sessionId']
+                    self.default_session_id = new_session_id
+                    print(f"è‡ªåŠ¨åˆ‡æ¢åˆ°æ–°æ ‡ç­¾ä¼šè¯: {new_session_id}")
+            return response.get('result', None)
+ 
+        session = self.sessions.get(session_id)
+        if not session or not session.is_active(): 
+            time.sleep(3)
+            session = self.sessions.get(session_id)
+            if not session or not session.is_active(): 
+                alive_sessions = [s for s in self.sessions.values() if s.is_active()]
+                if alive_sessions:
+                    session = alive_sessions[0]  
+                    print(f"ä¼šè¯ {session_id} æœªè¿æ¥ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°æœ€æ–°æ´»åŠ¨ä¼šè¯: {session.id}")
+                    session_id = self.default_session_id = session.id
+                if not session or not session.is_active(): 
+                    breakpoint()
+                    raise ValueError(f"ä¼šè¯ID {session_id} æœªè¿æ¥")  
+
+        tp = session.type
+        assert tp in ['ws', 'http'], f"Unsupported session type: {tp}"
+        exec_id = str(uuid.uuid4())  
+        payload = json.dumps({'id': exec_id, 'code': code, 'auto_switch_newtab': auto_switch_newtab})
+
+        if tp == 'ws':        
+            session.ws_client.send_message(payload)  
+        elif tp == 'http':
+            session.http_queue.put(payload)
+
+        start_time = time.time()  
+        self.clean_sessions() 
+        hasjump = False
+
+        while exec_id not in self.results:  
+            time.sleep(0.1)  
+            if tp == 'ws':
+                if not session.is_active(): hasjump = True
+                if hasjump and session.is_active():
+                    if not self.is_remote and auto_switch_newtab: self.last_cmd_time = time.time()
+                    return {"result": f"Session {session_id} reloaded.", "closed":1}
+            if time.time() - start_time > timeout:  
+                if tp == 'ws':
+                    return {"result": f"No response data in {timeout}s"}
+                elif tp == 'http':
+                    return {"result": f"Session {session_id} no response."}
+        
+        result = self.results.pop(exec_id)  
+        if not result['success']: raise Exception(result['data'])  
+        if not self.is_remote and auto_switch_newtab:
+            newtabs = result.get('newTabs', [])
+            if len(newtabs) > 0:
+                new_session_id = newtabs[0]['sessionId']
+                self.default_session_id = new_session_id
+                print(f"è‡ªåŠ¨åˆ‡æ¢åˆ°æ–°æ ‡ç­¾ä¼šè¯: {new_session_id}")
+        elif not self.is_remote:
+            self.last_cmd_time = time.time()
+        return result['data']  
+    
+    def _remote_cmd(self, cmd):
+        resp = requests.post(self.remote, 
+            headers={"Content-Type": "application/json"},
+            json=cmd).json()
+        return resp
+
+    def get_all_sessions(self):  
+        if self.is_remote:
+            return self._remote_cmd({"cmd": "get_all_sessions"}).get('r', [])
+        return [{'id': session.id, **session.info} for session in self.sessions.values()
+                if session.is_active()]  
+
+    def get_session_dict(self):
+        return {session.id: session.url for session in self.sessions.values() if session.is_active()}
+        
+    def find_session(self, url_pattern: str):
+        if url_pattern == '': 
+            session = self.sessions.get(self.latest_session_id)
+            return [(session.id, session.info)] if session else []
+        matching_sessions = []  
+        for session in self.sessions.values():
+            if not session.is_active(): continue
+            if 'url' in session.info and url_pattern in session.info['url']:  
+                matching_sessions.append((session.id, session.info))  
+        return matching_sessions
+
+    def set_session(self, url_pattern: str) -> bool:  
+        if self.is_remote:
+            matched = self._remote_cmd({"cmd": "find_session", "url_pattern": url_pattern}).get('r', [])
+        else:
+            matched = self.find_session(url_pattern)
+        if not matched: return print(f"è­¦å‘Š: æœªæ‰¾åˆ°URLåŒ…å« '{url_pattern}' çš„ä¼šè¯")  
+        if len(matched) > 1: print(f"è­¦å‘Š: æ‰¾åˆ°å¤šä¸ªURLåŒ…å« '{url_pattern}' çš„ä¼šè¯ï¼Œé€‰æ‹©ç¬¬ä¸€ä¸ª")  
+        self.last_cmd_time = 0
+        self.default_session_id, info = matched[0]
+        print(f"æˆåŠŸè®¾ç½®é»˜è®¤ä¼šè¯: {self.default_session_id}: {info['url']}")  
+        return self.default_session_id  
+    
+    def jump(self, url, timeout=10): self.execute_js(f"window.location.href='{url}'", timeout=timeout)
+    def page_source(self): return self.execute_js("document.documentElement.outerHTML")
+    def body(self): return self.execute_js("document.body.outerHTML")
+    def newtab(self, url=None):
+        if url is None: url = "http://www.baidu.com/robots.txt"
+        return self.execute_js(f'GM_openInTab("{url}");', auto_switch_newtab=True)
+    
+if __name__ == "__main__":
+    driver = TMWebDriver(host='localhost', port=18765)
\ No newline at end of file
diff --git a/agent_loop.py b/agent_loop.py
new file mode 100644
index 0000000..e30eecb
--- /dev/null
+++ b/agent_loop.py
@@ -0,0 +1,67 @@
+import json
+from dataclasses import dataclass
+from typing import Any, Optional
+@dataclass
+class StepOutcome:
+    data: Any
+    next_prompt: Optional[str] = None
+    should_exit: bool = False
+
+
+def try_call_generator(func, *args, **kwargs):
+    ret = func(*args, **kwargs)
+    if hasattr(ret, '__iter__') and not isinstance(ret, (str, bytes, dict, list)):
+        ret = yield from ret
+    return ret
+
+class BaseHandler:
+    def tool_before_callback(self, tool_name, args, content): pass
+    def tool_after_callback(self, tool_name, args, content): pass
+    def dispatch(self, tool_name, args, response):
+        method_name = f"do_{tool_name}"
+        if hasattr(self, method_name):
+            _ = yield from try_call_generator(self.tool_before_callback, tool_name, args, response)
+            ret = yield from try_call_generator(getattr(self, method_name), args, response)
+            _ = yield from try_call_generator(self.tool_after_callback, tool_name, args, response)
+            return ret
+        else:
+            yield f"âŒ æœªçŸ¥å·¥å…·: {tool_name}\n"
+            return StepOutcome(None, "æœªçŸ¥å·¥å…·", "ERROR")
+
+def json_default(o):
+    if isinstance(o, set): return list(o)
+    return str(o) 
+
+def agent_runner_loop(client, system_prompt, user_input, handler, tools_schema, max_turns=15):
+    messages = [
+        {"role": "system", "content": system_prompt},
+        {"role": "user", "content": user_input}
+    ]
+    for turn in range(max_turns):
+        yield f"\n[ğŸ¤– LLM Thinking (Turn {turn+1})] ..."
+        response = client.chat(messages=messages, tools=tools_schema)
+
+        if response.thinking: yield '<thinking>' + response.thinking + '</thinking>\n'
+        yield response.content
+
+        if not response.tool_calls:
+            tool_name, args = 'no_tool', {}
+        else:
+            tool_call = response.tool_calls[0] 
+            tool_name = tool_call.function.name
+            args = json.loads(tool_call.function.arguments)
+
+        if tool_name == 'no_tool': pass
+        else: yield f"\n\næ­£åœ¨è°ƒç”¨å·¥å…·: {tool_name}ï¼Œå‚æ•°: {args}\n"
+        outcome = yield from handler.dispatch(tool_name, args, response)
+
+        if outcome.next_prompt is None: return {'result': 'CURRENT_TASK_DONE', 'data': outcome.data}
+        if outcome.should_exit: return {'result': 'EXITED', 'data': outcome.data}
+
+        next_prompt = ""
+        if outcome.data is not None: 
+            datastr = json.dumps(outcome.data, ensure_ascii=False, default=json_default) if type(outcome.data) in [dict, list] else str(outcome.data) 
+            next_prompt += f"<tool_result>\n{datastr}\n</tool_result>\n\n"
+        next_prompt += outcome.next_prompt
+        messages = [{"role": "user", "content": next_prompt}]
+    return {'result': 'MAX_TURNS_EXCEEDED'}
\ No newline at end of file
diff --git a/agentapp.py b/agentapp.py
new file mode 100644
index 0000000..915921d
--- /dev/null
+++ b/agentapp.py
@@ -0,0 +1,94 @@
+import os, sys
+if sys.stdout is None: sys.stdout = open(os.devnull, "w")
+if sys.stderr is None: sys.stderr = open(os.devnull, "w")
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+
+
+import streamlit as st
+import time, json, re
+
+with open('tools_schema.json', 'r', encoding='utf-8') as f:
+    TOOLS_SCHEMA = json.load(f)
+
+
+st.set_page_config(page_title="Cowork", layout="wide")
+
+from sidercall import SiderLLMSession, LLMSession, ToolClient
+from agent_loop import agent_runner_loop, StepOutcome, BaseHandler
+
+@st.cache_resource
+def init():
+    mainllm = SiderLLMSession(multiturns=6)
+    llmclient = ToolClient(mainllm.ask, auto_save_tokens=True)
+    return llmclient
+
+llmclient = init()
+
+from ga import GenericAgentHandler
+
+def get_system_prompt():
+    with open('sys_prompt.txt', 'r', encoding='utf-8') as f:
+        return f.read()
+
+if "last_goal" not in st.session_state:
+    st.session_state.last_goal = ""
+
+def refine_user_goal(raw_query, last_goal):
+    """é€šè¿‡ LLM æç‚¼ç”¨æˆ·çœŸå®æ„å›¾"""
+    if not last_goal:
+        return raw_query
+
+    decide_prompt = f"""
+ç”¨æˆ·ä¹‹å‰çš„ç›®æ ‡æ˜¯: "{last_goal}"
+ç”¨æˆ·ç°åœ¨è¾“å…¥äº†: "{raw_query}"
+
+è¯·åˆ¤æ–­ï¼š
+1. å¦‚æœç”¨æˆ·æä¾›è¡¥å……ä¿¡æ¯ã€æˆ–è€…æ˜¯æ¥ç»­ä¹‹å‰çš„ä»»åŠ¡ï¼Œè¯·è¾“å‡ºåˆå¹¶åçš„ã€æœ€ç»ˆç›®æ ‡ã€‘ã€‚
+2. å¦‚æœç”¨æˆ·åªæ˜¯æŒ‡å‡ºä¹‹å‰åšæ³•æœ‰é”™è€Œéå˜æ›´ç›®æ ‡ï¼Œé‚£ä¹ˆè¯·è¾“å‡ºåŸç›®æ ‡ä¸åšä¿®æ”¹ã€‚
+3. å¦‚æœç”¨æˆ·å¼€å¯äº†ä¸€ä¸ªå®Œå…¨ä¸ç›¸å…³çš„æ–°è¯é¢˜ï¼Œè¯·ç›´æ¥è¾“å‡ºç”¨æˆ·ç°åœ¨çš„è¾“å…¥å†…å®¹ã€‚
+
+è¯·ç›´æ¥è¾“å‡ºç›®æ ‡æè¿°ï¼Œä¸è¦åŒ…å«ä»»ä½•å¤šä½™çš„æ–‡å­—ã€è§£é‡Šæˆ–æ ‡ç‚¹ã€‚
+"""
+    try:
+        refined = llmclient.llm_func(decide_prompt).strip()
+        return refined if refined else raw_query
+    except:
+        return raw_query
+
+def agent_backend_stream(raw_query):
+    final_goal = refine_user_goal(raw_query, st.session_state.last_goal)
+    
+    if final_goal != raw_query:
+        yield f"[Goal Refined] {final_goal}\n"
+
+    sys_prompt = get_system_prompt()
+    handler = GenericAgentHandler(None, final_goal, './temp')
+    llmclient.last_tools = ''   
+    ret = yield from agent_runner_loop(llmclient,
+        sys_prompt, raw_query, handler,
+        TOOLS_SCHEMA, max_turns=25)
+    st.session_state.last_goal = final_goal
+    return ret
+
+st.title("ğŸ–¥ï¸ Cowork")
+
+if "messages" not in st.session_state:
+    st.session_state.messages = []
+
+for msg in st.session_state.messages:
+    with st.chat_message(msg["role"]):
+        st.markdown(msg["content"])
+
+if prompt := st.chat_input("è¯·è¾“å…¥æŒ‡ä»¤"):
+    st.session_state.messages.append({"role": "user", "content": prompt})
+    with st.chat_message("user"):
+        st.markdown(prompt)
+
+    with st.chat_message("assistant"):
+        message_placeholder = st.empty()
+        full_response = ""
+        for chunk in agent_backend_stream(prompt):
+            full_response += chunk
+            message_placeholder.markdown(full_response + "â–Œ")
+        message_placeholder.markdown(full_response)
+    st.session_state.messages.append({"role": "assistant", "content": full_response})
\ No newline at end of file
diff --git a/ga.py b/ga.py
new file mode 100644
index 0000000..446a7a3
--- /dev/null
+++ b/ga.py
@@ -0,0 +1,379 @@
+import sys, os, re
+import pyperclip
+import json, time
+from pathlib import Path
+import subprocess
+import tempfile
+if sys.stdout is None: sys.stdout = open(os.devnull, "w")
+if sys.stderr is None: sys.stderr = open(os.devnull, "w")
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+
+from sidercall import LLMSession, ToolClient
+from agent_loop import BaseHandler, StepOutcome, agent_runner_loop
+
+def code_run(code: str, code_type: str = "python", timeout: int = 60, cwd: str = None):
+    """
+    é’ˆå¯¹ Windows ä¼˜åŒ–çš„åŒæ¨¡æ€æ‰§è¡Œå™¨
+    python: è¿è¡Œå¤æ‚çš„ .py è„šæœ¬ï¼ˆæ–‡ä»¶æ¨¡å¼ï¼‰
+    powershell: è¿è¡Œå•è¡ŒæŒ‡ä»¤ï¼ˆå‘½ä»¤æ¨¡å¼ï¼‰
+    ä¼˜å…ˆä½¿ç”¨pythonï¼Œä»…åœ¨å¿…è¦ç³»ç»Ÿæ“ä½œæ—¶ä½¿ç”¨powershellã€‚
+    """
+    # ç»Ÿä¸€è·¯å¾„å¤„ç†
+    preview = (code[:60].replace('\n', ' ') + '...') if len(code) > 60 else code.strip()
+    yield f"\n[Action] Running {code_type} in {os.path.basename(cwd)}: {preview}\n"
+    cwd = cwd or os.getcwd()
+    if code_type == "python":
+        # Python ä¾ç„¶å»ºè®®èµ°æ–‡ä»¶ï¼Œå› ä¸ºæ¨¡å‹ç”Ÿæˆçš„é€»è¾‘é€šå¸¸åŒ…å«å¤šè¡Œã€import å’Œç±»å®šä¹‰
+        tmp_file = tempfile.NamedTemporaryFile(suffix=".py", delete=False, mode='w', encoding='utf-8')
+        tmp_file.write(code)
+        tmp_path = tmp_file.name
+        tmp_file.close()
+        cmd = ["python", "-u", tmp_path]   
+    elif code_type == "powershell":
+        cmd = ["powershell", "-NoProfile", "-NonInteractive", "-Command", code]
+        tmp_path = None
+    else:
+        return {"status": "error", "msg": f"ä¸æ”¯æŒçš„ç±»å‹: {code_type}"}
+    print("code run output:") 
+    startupinfo = None
+    if os.name == 'nt':
+        startupinfo = subprocess.STARTUPINFO()
+        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
+        startupinfo.wShowWindow = 0 # SW_HIDE
+    full_stdout = []
+    full_stderr = []
+    try:
+        process = subprocess.Popen(
+            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
+            bufsize=0, cwd=cwd, startupinfo=startupinfo
+        )
+        for line_bytes in iter(process.stdout.readline, b''):
+            try:
+                line = line_bytes.decode('utf-8')
+            except UnicodeDecodeError:
+                line = line_bytes.decode('gbk', errors='ignore')
+            print(line, end="") 
+            full_stdout.append(line)
+
+        stdout_rem, stderr_raw = process.communicate(timeout=timeout)
+        if stdout_rem:
+            try: rem_str = stdout_rem.decode('utf-8')
+            except UnicodeDecodeError:
+                rem_str = stdout_rem.decode('gbk', errors='ignore')
+            full_stdout.append(rem_str)
+            
+        if stderr_raw:
+            try: stderr_str = stderr_raw.decode('utf-8')
+            except UnicodeDecodeError:
+                stderr_str = stderr_raw.decode('gbk', errors='ignore')
+            full_stderr.append(stderr_str)
+            print(f"Error: {stderr_str}")
+       
+        status = "success" if process.returncode == 0 else "error"
+        stdout_str = "".join(full_stdout)
+        stderr_str = "".join(full_stderr)
+        status_icon = "âœ…" if process.returncode == 0 else "âŒ"
+        output_snippet = (stdout_str[:200] + '...') if len(stdout_str) > 200 else stdout_str
+        yield f"[Status] {status_icon} Exit Code: {process.returncode}\n[Stdout] {output_snippet}\n"
+        return {
+            "status": status,
+            "stdout": stdout_str[-2000:],
+            "stderr": stderr_str[-2000:],
+            "exit_code": process.returncode
+        }
+    except subprocess.TimeoutExpired:
+        return {"status": "error", "msg": "Timeout"}
+    except Exception as e:
+        return {"status": "error", "msg": str(e)}
+    finally:
+        if code_type == "python" and tmp_path and os.path.exists(tmp_path): os.remove(tmp_path)
+
+
+def ask_user(question: str, candidates: list = None):
+    """
+    æ„é€ ä¸€ä¸ªä¸­æ–­è¯·æ±‚ã€‚
+    question: å‘ç”¨æˆ·æå‡ºçš„é—®é¢˜ã€‚
+    candidates: å¯é€‰çš„å€™é€‰é¡¹åˆ—è¡¨ã€‚
+    éœ€è¦ä¿è¯should_exitä¸ºTrue
+    """
+    return {
+        "status": "INTERRUPT",
+        "intent": "HUMAN_INTERVENTION",
+        "data": {
+            "question": question,
+            "candidates": candidates or []
+        }
+    }
+
+from web_tools import execute_js_rich, get_html
+
+driver = None
+
+def first_init_driver():
+    global driver
+    from TMWebDriver import TMWebDriver
+    driver = TMWebDriver()
+    while True:
+        time.sleep(1)
+        sess = driver.get_all_sessions()
+        if len(sess) > 0: break
+    driver.newtab()
+    time.sleep(5)
+
+def web_scan(focus_item="", switch_tab_id=None):
+    """
+    åˆ©ç”¨ get_html è·å–æ¸…æ´—åçš„ç½‘é¡µå†…å®¹ã€‚
+    focus_item: è¯­ä¹‰è¿‡æ»¤æŒ‡ä»¤ã€‚å¦‚æœç”¨æˆ·åœ¨æ‰¾ç‰¹å®šå†…å®¹ï¼ˆå¦‚â€œå°ç±³æ±½è½¦â€ï¼‰ï¼Œ
+                       ç®—æ³•ä¼šä¼˜å…ˆä¿ç•™åŒ…å«è¯¥å…³é”®è¯çš„åˆ—è¡¨é¡¹ã€‚
+    switch_tab_id: å¯é€‰å‚æ•°ï¼Œå¦‚æœæä¾›ï¼Œåˆ™åœ¨æ‰«æå‰åˆ‡æ¢åˆ°è¯¥æ ‡ç­¾é¡µã€‚
+    åº”å½“å¤šç”¨execute_jsï¼Œå°‘å…¨é‡è§‚å¯Ÿhtmlã€‚
+    """
+    global driver
+    if driver is None: first_init_driver()
+    try:
+        tabs = []
+        for sess in driver.get_all_sessions(): 
+            sess.pop('connected_at', None)
+            sess.pop('type', None)
+            sess['url'] = sess.get('url', '')[:50] + ("..." if len(sess.get('url', '')) > 50 else "")
+            tabs.append(sess)
+        if switch_tab_id: driver.default_session_id = switch_tab_id
+        content = get_html(driver, cutlist=True, instruction=focus_item, maxchars=23000)
+        return {
+            "status": "success",
+            "metadata": {
+                "tabs_count": len(tabs),
+                "tabs": tabs,
+                "active_tab": driver.default_session_id
+            },
+            "content": content
+        }
+    except Exception as e:
+        return {"status": "error", "msg": format_error(e)}
+    
+import traceback
+def format_error(e):
+    exc_type, exc_value, exc_traceback = sys.exc_info()
+    tb = traceback.extract_tb(exc_traceback)
+    if tb:
+        f = tb[-1]
+        fname = os.path.basename(f.filename)
+        return f"{exc_type.__name__}: {str(e)} @ {fname}:{f.lineno}, {f.name} -> `{f.line}`"
+    return f"{exc_type.__name__}: {str(e)}"
+
+def web_execute_js(script: str):
+    """
+    æ‰§è¡Œ JS è„šæœ¬æ¥æ§åˆ¶æµè§ˆå™¨ï¼Œå¹¶æ•è·ç»“æœå’Œé¡µé¢å˜åŒ–ã€‚
+    script: è¦æ‰§è¡Œçš„ JavaScript ä»£ç å­—ç¬¦ä¸²ã€‚
+    return {
+        "status": "failed" if error_msg else "success",
+        "js_return": result,
+        "error": error_msg,
+        "transients": transients, 
+        "environment": {
+            "new_tab": new_tab,
+            "reloaded": reloaded
+        },
+        "diff": diff_summary,
+        "suggestion": "" if is_significant_change else "é¡µé¢æ— æ˜æ˜¾å˜åŒ–"
+    }
+    """
+    global driver
+    if driver is None: first_init_driver()
+    try:
+        result = execute_js_rich(script, driver)
+        return result
+    except Exception as e:
+        return {"status": "error", "msg": format_error(e)}
+    
+def file_patch(path: str, old_content: str, new_content: str):
+    """
+    åœ¨æ–‡ä»¶ä¸­å¯»æ‰¾å”¯ä¸€çš„ old_content å—å¹¶æ›¿æ¢ä¸º new_contentã€‚
+    """
+    path = str(Path(path).resolve())
+    try:
+        if not os.path.exists(path):
+            return {"status": "error", "msg": "æ–‡ä»¶ä¸å­˜åœ¨"}
+        with open(path, 'r', encoding='utf-8') as f:
+            full_text = f.read()
+        # æ£€æŸ¥å”¯ä¸€æ€§
+        count = full_text.count(old_content)
+        if count == 0:
+            return {"status": "error", "msg": "æœªæ‰¾åˆ°åŒ¹é…çš„æ—§æ–‡æœ¬å—ï¼Œè¯·æ£€æŸ¥ç©ºæ ¼ã€ç¼©è¿›å’Œæ¢è¡Œæ˜¯å¦å®Œå…¨ä¸€è‡´ã€‚"}
+        if count > 1:
+            return {"status": "error", "msg": f"æ‰¾åˆ° {count} å¤„åŒ¹é…ï¼Œè¯·æä¾›æ›´é•¿çš„æ—§æ–‡æœ¬å—ä»¥ç¡®ä¿å”¯ä¸€æ€§ã€‚"}
+        updated_text = full_text.replace(old_content, new_content)
+        with open(path, 'w', encoding='utf-8') as f:
+            f.write(updated_text)
+        return {"status": "success", "msg": "æ–‡ä»¶å±€éƒ¨ä¿®æ”¹æˆåŠŸ"}
+    except Exception as e:
+        return {"status": "error", "msg": str(e)}
+
+def file_read(path, start=1, count=100, show_linenos=True):
+    try:
+        with open(path, 'r', encoding='utf-8', errors='replace') as f:
+            lines = f.readlines()
+        chunk = lines[start-1 : start-1+count]
+        if show_linenos: res = [f"{i+start}|{l[:200]}" for i, l in enumerate(chunk)]
+        else: res = [l for l in chunk]
+        return f"Total:{len(lines)} lines\n" + "".join(res)
+    except Exception as e:
+        return f"Error: {str(e)}"
+
+class GenericAgentHandler(BaseHandler):
+    '''
+    Generic Agent å·¥å…·åº“ï¼ŒåŒ…å«å¤šç§å·¥å…·çš„å®ç°ã€‚å·¥å…·å‡½æ•°è‡ªåŠ¨åŠ ä¸Šäº† do_ å‰ç¼€ã€‚å®é™…å·¥å…·åæ²¡æœ‰å‰ç¼€ã€‚
+    '''
+    def __init__(self, parent, user_input, cwd):
+        self.parent = parent
+        self.user_input = user_input
+        self.plan = ""
+        self.focus = ""
+        self.cwd = cwd
+
+    def _get_abs_path(self, path):
+        if not path: return ""
+        return os.path.abspath(os.path.join(self.cwd, path))
+
+    def do_code_run(self, args, response):
+        '''æ‰§è¡Œä»£ç ç‰‡æ®µï¼Œæœ‰é•¿åº¦é™åˆ¶ï¼Œä¸å…è®¸ä»£ç ä¸­æ”¾å¤§é‡æ•°æ®ï¼Œå¦‚æœ‰éœ€è¦åº”å½“é€šè¿‡æ–‡ä»¶è¯»å–è¿›è¡Œã€‚
+        '''
+        code_type = args.get("type", "python")
+        # ä» response.content ä¸­æå–ä»£ç å—
+        # åŒ¹é… ```python ... ``` æˆ– ```powershell ... ```
+        pattern = rf"```{code_type}\n(.*?)\n```"
+        # ä¹Ÿå¯ä»¥æ›´é€šç”¨ä¸€ç‚¹ï¼Œä¸åˆ†ç±»å‹æå–æœ€åä¸€ä¸ªä»£ç å—ï¼šrf"```(?:{code_type})?\n(.*?)\n```"
+        matches = re.findall(pattern, response.content, re.DOTALL)
+        if not matches:
+            return StepOutcome(None, next_prompt=f"ã€ç³»ç»Ÿé”™è¯¯ã€‘ï¼šä½ è°ƒç”¨äº† code_runï¼Œä½†æœªåœ¨å›å¤ä¸­æä¾› ```{code_type} ä»£ç å—ã€‚è¯·é‡æ–°è¾“å‡ºä»£ç å¹¶é™„å¸¦å·¥å…·è°ƒç”¨ã€‚")       
+        # æå–æœ€åä¸€ä¸ªä»£ç å—ï¼ˆé€šå¸¸æ˜¯æ¨¡å‹ä¿®æ­£åçš„æœ€ç»ˆé€»è¾‘ï¼‰
+        code = matches[-1].strip()
+        timeout = args.get("timeout", 60)
+        cwd = args.get("cwd", self.cwd)
+        result = yield from code_run(code, code_type, timeout, cwd)
+        return StepOutcome(result, next_prompt=self._get_anchor_prompt())
+    
+    def do_ask_user(self, args, response):
+        question = args.get("question", "è¯·æä¾›è¾“å…¥ï¼š")
+        candidates = args.get("candidates", [])
+        result = ask_user(question, candidates)
+        return StepOutcome(result, next_prompt="", should_exit=True)
+    
+    def do_web_scan(self, args, response):
+        '''focus_itemä»…ç”¨äºåœ¨é•¿åˆ—è¡¨ä¸­æ¨¡ç³Šæœå¯»ç›¸å…³item
+        æ­¤å·¥å…·ä¹Ÿæä¾›æ ‡ç­¾é¡µæŸ¥çœ‹å’Œæ ‡ç­¾é¡µåˆ‡æ¢åŠŸèƒ½ã€‚
+        '''
+        focus_item = args.get("focus_item", "")
+        switch_tab_id = args.get("switch_tab_id", None)
+        result = web_scan(focus_item, switch_tab_id=switch_tab_id)
+        content = result.pop("content", None) 
+        yield f'\n{str(result)}\n'
+        next_prompt = f"```html\n{content}\n```"
+        return StepOutcome(result, next_prompt=next_prompt)
+    
+    def do_web_execute_js(self, args, response):
+        '''webæƒ…å†µä¸‹çš„ä¼˜å…ˆä½¿ç”¨å·¥å…·ï¼Œæ‰§è¡Œä»»ä½•jsè¾¾æˆå¯¹æµè§ˆå™¨çš„*å®Œå…¨*æ§åˆ¶ã€‚
+        æ”¯æŒå°†ç»“æœä¿å­˜åˆ°æ–‡ä»¶ä¾›åç»­è¯»å–åˆ†æï¼Œä½†ä¿å­˜åŠŸèƒ½ä»…é™å³æ—¶è¯»å–ï¼Œä¸awaitç­‰å¼‚æ­¥æ“ä½œä¸å…¼å®¹ã€‚
+        '''
+        script = args.get("script", "")
+        save_to_file = args.get("save_to_file", "")
+        result = web_execute_js(script)
+        if save_to_file and "js_return" in result:
+            content = str(result["js_return"] or '')
+            abs_path = self._get_abs_path(save_to_file)
+            with open(abs_path, 'w', encoding='utf-8') as f: f.write(str(content))
+            result["js_return"] = content[:200] + ("..." if len(content) > 200 else "")
+            result["js_return"] += f"\n\n[å·²ä¿å­˜ä»¥ä¸Šå†…å®¹åˆ° {abs_path}]"
+        print("Web Execute JS Result:", result)
+        return StepOutcome(result, next_prompt=self._get_anchor_prompt())
+    
+    def do_file_patch(self, args, response):
+        path = self._get_abs_path(args.get("path", ""))
+        yield f"\n[Action] Patching file: {path}\n"
+        old_content = args.get("old_content", "")
+        new_content = args.get("new_content", "")
+        result = file_patch(path, old_content, new_content)
+        yield str(result) + "\n"
+        return StepOutcome(result, next_prompt=self._get_anchor_prompt())
+    
+    def do_file_write(self, args, response):
+        '''ç”¨äºå¯¹æ•´ä¸ªæ–‡ä»¶çš„å¤§é‡å¤„ç†ï¼Œç²¾ç»†ä¿®æ”¹è¦ç”¨file_patchã€‚
+        '''
+        path = self._get_abs_path(args.get("path", ""))
+        mode = args.get("mode", "overwrite") 
+        action_str = "Appending to" if mode == "append" else "Writing"
+        yield f"\n[Action] {action_str} file: {os.path.basename(path)}\n"
+
+        def extract_intended_block(content):
+            start_marker = "```"
+            first_idx = content.find(start_marker)
+            last_idx = content.rfind(start_marker)
+            if first_idx == -1 or last_idx == -1 or first_idx == last_idx:
+                return None
+            header_end = content.find("\n", first_idx)
+            if header_end == -1 or header_end > last_idx:
+                return None
+            actual_content = content[header_end + 1 : last_idx].strip()
+            return actual_content
+        
+        blocks = extract_intended_block(response.content)
+        if not blocks:
+            yield f"[Status] âŒ å¤±è´¥: æœªåœ¨å›å¤ä¸­æ‰¾åˆ°ä»£ç å—å†…å®¹\n"
+            return StepOutcome({"status": "error", "msg": "No code block found in response"}, next_prompt="\n")
+        new_content = blocks
+        try:
+            write_mode = 'a' if mode == "append" else 'w'
+            final_content = ("\n" + new_content) if mode == "append" else new_content
+            with open(path, write_mode, encoding="utf-8") as f:
+                f.write(final_content)
+            yield f"[Status] âœ… {mode.capitalize()} æˆåŠŸ ({len(new_content)} bytes)\n"
+            return StepOutcome({"status": "success"}, 
+                               next_prompt=f"\næé†’: <user_input>{self.user_input}</user_input>è¯·ç»§ç»­æ‰§è¡Œä¸‹ä¸€æ­¥ã€‚\n")
+        except Exception as e:
+            yield f"[Status] âŒ å†™å…¥å¼‚å¸¸: {str(e)}\n"
+            return StepOutcome({"status": "error", "msg": str(e)}, next_prompt="\n")
+        
+    def do_file_read(self, args, response):
+        path = self._get_abs_path(args.get("path", ""))
+        yield f"\n[Action] Reading file: {path}\n"
+        start = args.get("start", 1)
+        count = args.get("count", 100)
+        show_linenos = args.get("show_linenos", True)
+        result = file_read(path, start, count, show_linenos)
+        return StepOutcome(result, next_prompt=self._get_anchor_prompt())
+    
+    def do_update_plan(self, args, response):
+        '''
+        åŒæ­¥å®è§‚ä»»åŠ¡è¿›åº¦ä¸æˆ˜ç•¥é‡å¿ƒã€‚       
+        ã€è®¾è®¡æ„å›¾ã€‘ï¼š
+        1. ä»…åœ¨ä»»åŠ¡æ¶‰åŠå¤šæ­¥é€»è¾‘ï¼ˆå¦‚ï¼šå…ˆæœç´¢ã€å†é‡æ„ã€åæµ‹è¯•ï¼‰æ—¶è¿›è¡Œåˆå§‹æ‹†è§£ã€‚
+        2. ä»…åœ¨å‘ç”Ÿé‡å¤§çš„æ–¹é’ˆå˜æ›´æ—¶è°ƒç”¨ï¼ˆä¾‹å¦‚ï¼šåŸå®šæ–¹æ¡ˆ A ç‰©ç†ä¸å¯è¡Œï¼Œéœ€å½»åº•è½¬å‘æ–¹æ¡ˆ Bï¼‰ã€‚
+        3. ä¸¥ç¦ç”¨äºè®°å½•ç»†å¾®çš„è°ƒè¯•æ­¥éª¤æˆ–ä»£ç çº é”™ã€‚
+        ç®€å•ä»»åŠ¡æ— éœ€ä½¿ç”¨ã€‚
+        '''
+        new_plan = args.get("plan", "")
+        new_focus = args.get("focus", "")
+        if new_plan: self.plan = new_plan
+        if new_focus: self.focus = new_focus
+        yield f"\n[Info] Updated plan and focus.\n"
+        yield f"New Plan:\n{self.plan}\n\n"
+        yield f"New Focus:\n{self.focus}\n"
+        return StepOutcome({"status": "success"}, 
+                           next_prompt=self._get_anchor_prompt())
+
+    def do_no_tool(self, args, response):
+        '''è¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šå·¥å…·ï¼Œç”±å¼•æ“è‡ªä¸»è°ƒç”¨ï¼Œä¸è¦åŒ…å«åœ¨TOOLS_SCHEMAé‡Œã€‚
+        '''
+        yield "\n\n[Info] No tool called. Final response to user.\n"
+        return StepOutcome(response, next_prompt=None, should_exit=True)
+    
+    def _get_anchor_prompt(self):
+        prompt = f"\næé†’: \n<user_input>{self.user_input}</user_input>\n"
+        if self.plan: prompt += f"<plan>\n{self.plan}\n</plan>\n"
+        if self.focus: prompt += f"<current>\n{self.focus}\n</current>\n"
+        prompt += "\nè¯·ç»§ç»­æ‰§è¡Œä¸‹ä¸€æ­¥ã€‚"
+        return prompt
+
+
+if __name__ == "__main__":
+    pass
\ No newline at end of file
diff --git a/launch.pyw b/launch.pyw
new file mode 100644
index 0000000..4b91d6f
--- /dev/null
+++ b/launch.pyw
@@ -0,0 +1,48 @@
+import webview
+import threading
+import subprocess
+import sys, time, os, ctypes
+import atexit
+
+# === é…ç½®åŒºåŸŸ ===
+WINDOW_WIDTH = 600
+WINDOW_HEIGHT = 900
+RIGHT_PADDING = 0  # ç¦»å±å¹•å³è¾¹ç¼˜çš„è·ç¦»
+TOP_PADDING = 300    # ç¦»å±å¹•ä¸Šè¾¹ç¼˜çš„è·ç¦»
+
+def get_screen_width():
+    try:
+        # GetSystemMetrics(0) è·å–ä¸»å±å¹•å®½åº¦
+        user32 = ctypes.windll.user32
+        return user32.GetSystemMetrics(0)
+    except:
+        # å¦‚æœä¸æ˜¯ Windows æˆ–è€…å‡ºé”™äº†ï¼Œè¿”å›ä¸€ä¸ªå…œåº•å€¼ (æ¯”å¦‚ 1920)
+        return 1920
+
+def start_streamlit():
+    global proc
+    cmd = [
+        sys.executable, "-m", "streamlit", "run", "agentapp.py", 
+        "--server.port", "8501", 
+        "--server.headless", "true",
+        "--theme.base", "dark" #ä»¥æ­¤é»˜è®¤å¼€å¯æš—é»‘æ¨¡å¼ï¼Œæ›´æœ‰æå®¢æ„Ÿ
+    ]
+    proc = subprocess.Popen(cmd)
+    atexit.register(proc.kill)
+
+if __name__ == '__main__':
+    t = threading.Thread(target=start_streamlit, daemon=True)
+    t.start()
+    screen_width = get_screen_width()
+    x_pos = screen_width - WINDOW_WIDTH - RIGHT_PADDING
+    time.sleep(2) 
+    webview.create_window(
+        title='GenericAgent', 
+        url='http://localhost:8501',
+        width=WINDOW_WIDTH, 
+        height=WINDOW_HEIGHT,
+        x=x_pos, y=TOP_PADDING,
+        resizable=True,
+        text_select=True
+    )
+    webview.start()
\ No newline at end of file
diff --git a/ljq_web_driver.user.js b/ljq_web_driver.user.js
new file mode 100644
index 0000000..01eb42b
--- /dev/null
+++ b/ljq_web_driver.user.js
@@ -0,0 +1,428 @@
+// ==UserScript==
+// @name         ljq_web_driver
+// @namespace    http://tampermonkey.net/
+// @version      0.2
+// @description  Execute JS via ljq_web_driver
+// @require      https://code.jquery.com/jquery-3.6.0.min.js
+// @author       You
+// @match        *://*/*
+// @grant        GM_setValue
+// @grant        GM_getValue
+// @grant        GM_xmlhttpRequest
+// @grant        GM_openInTab
+// @grant        unsafeWindow
+// @connect      localhost
+// @run-at       document-start
+// ==/UserScript==
+
+
+(function() {
+    'use strict';
+    const log_prefix = "ljq_driver: ";
+
+    if (window.self !== window.top) {
+        console.log(log_prefix + 'åœ¨iframeä¸­ä¸æ‰§è¡Œ');
+        return;
+    }
+
+    const wsUrl = 'ws://localhost:18765';
+    const httpUrl = 'http://localhost:18766/';
+    
+    function isWebSocketServerAlive(callback) {
+        GM_xmlhttpRequest({
+            method: 'GET',
+            url: 'http://localhost:18765/',
+            onload: () => callback(true),
+            onerror: () => callback(false)
+        });
+    }
+
+    let ws;
+    let sid = (window.name && window.name.startsWith('ljq_')) ? 
+          window.name : window.sessionStorage.getItem('ljq_driver_sid');
+    if (!sid) {
+        sid = `ljq_${Date.now().toString().slice(-2)}${Math.random().toString(36).slice(2, 4)}`;
+        window.sessionStorage.setItem('ljq_driver_sid', sid);
+        window.name = sid;
+        console.log(log_prefix + `åˆ›å»ºæ–°ä¼šè¯ID: ${sid}`);
+    } else {
+        if (window.name !== sid) window.name = sid;
+        console.log(log_prefix + `ä½¿ç”¨ç°æœ‰ä¼šè¯ID: ${sid}`);
+    }
+
+    try {
+        GM_setValue('new_tab_report', {
+            url: window.location.href,
+            sessionId: sid, 
+            ts: Date.now()
+        });
+    } catch (e) {}
+
+    // ä¿å­˜ä¼šè¯ID
+    GM_setValue('sid', sid);
+
+    // è·å–æˆ–åˆ›å»ºçŠ¶æ€æŒ‡ç¤ºå™¨
+    function getIndicator() {
+        // æ£€æŸ¥ç°æœ‰æŒ‡ç¤ºå™¨
+        let ind = document.getElementById('ljq-ind');
+
+        // åˆ é™¤é‡å¤æŒ‡ç¤ºå™¨
+        const dups = document.querySelectorAll('[id="ljq-ind"]');
+        if (dups.length > 1) {
+            for (let i = 1; i < dups.length; i++) {
+                dups[i].remove();
+            }
+            ind = dups[0];
+        }
+
+        // åˆ›å»ºæ–°æŒ‡ç¤ºå™¨
+        if (!ind && document.body) {
+            ind = document.createElement('div');
+            ind.id = 'ljq-ind';
+            ind.style.cssText = `
+                position: fixed;bottom: 10px;
+                right: 10px;background-color: #f44336;
+                color: white;padding: 8px 12px;
+                border-radius: 6px;font-size: 14px;
+                font-weight: bold;z-index: 9999;
+                transition: background-color 0.3s;
+                cursor: pointer;box-shadow: 0 3px 6px rgba(0,0,0,0.25);
+            `;
+            ind.innerText = log_prefix + 'æ­£åœ¨è¿æ¥...';
+
+            ind.addEventListener('click', () => alert(`ä¼šè¯ID: ${sid}\nå½“å‰URL: ${location.href}`));
+            document.body.appendChild(ind);
+        }
+
+        return ind;
+    }
+
+    // æ›´æ–°çŠ¶æ€
+    function updateStatus(status, msg) {
+        if (!document.body) return setTimeout(() => updateStatus(status, msg), 100);
+
+        const ind = getIndicator();
+        if (!ind) return;
+
+        if (status === 'ok') {
+            ind.style.backgroundColor = '#4CAF50';
+            ind.innerText = log_prefix + 'è¿æ¥æˆåŠŸ';
+        } else if (status === 'disc') {
+            ind.style.backgroundColor = '#f44336';
+            ind.innerText = log_prefix + 'è¿æ¥æ–­å¼€';
+        } else if (status === 'conn') {
+            ind.style.backgroundColor = '#2196F3';
+            ind.innerText = log_prefix + 'æ­£åœ¨è¿æ¥(HTTP)';
+        } else if (status === 'err') {
+            ind.style.backgroundColor = '#FF9800';
+            ind.innerText = log_prefix + `å‘ç”Ÿé”™è¯¯ (${msg})`;
+        } else if (status === 'exec') {
+            ind.style.backgroundColor = '#2196F3';
+            ind.innerText = log_prefix + 'æ­£åœ¨æ‰§è¡ŒæŒ‡ä»¤...';
+        }
+    }
+
+    function handleError(id, error, errorSource) {
+        console.error(`${errorSource}é”™è¯¯:`, error);
+        updateStatus('err', error.message);
+
+        const errorMessage = {
+            type: 'error',
+            id: id,
+            sessionId: sid,
+            error: {
+                name: error.name,
+                message: error.message,
+                stack: error.stack,
+                source: errorSource
+            }
+        };
+
+        if (typeof ws !== 'undefined' && ws && ws.readyState === WebSocket.OPEN) {
+            ws.send(JSON.stringify(errorMessage));
+        } else {
+            GM_xmlhttpRequest({
+                method: "POST",
+                url: httpUrl + "api/result",
+                headers: {"Content-Type": "application/json"},
+                data: JSON.stringify(errorMessage),
+                onload: function(response) {console.log("é”™è¯¯ä¿¡æ¯å·²é€šè¿‡HTTPå‘é€", response);},
+                onerror: function(err) {console.error("å‘é€é”™è¯¯ä¿¡æ¯å¤±è´¥", err);}
+            });
+        }
+    }
+
+    function smartProcessResult(result) {
+        // å¤„ç† null å’ŒåŸå§‹ç±»å‹
+        if (result === null || result === undefined || typeof result !== 'object') {
+            return result;
+        }
+
+        // 1. å¤„ç† jQuery å¯¹è±¡ - å¼ºåˆ¶è½¬æ¢ä¸ºHTMLå­—ç¬¦ä¸²æ•°ç»„
+        if (typeof jQuery !== 'undefined' && result instanceof jQuery) {
+            const elements = [];
+            for (let i = 0; i < result.length; i++) {
+                if (result[i] && result[i].nodeType === 1) {
+                    elements.push(result[i].outerHTML);
+                }
+            }
+            return elements; // å§‹ç»ˆè¿”å›æ•°ç»„
+        }
+
+        // 2. å¤„ç† NodeList å’Œ HTMLCollection
+        if (result instanceof NodeList || result instanceof HTMLCollection) {
+            const elements = [];
+            for (let i = 0; i < result.length; i++) {
+                if (result[i] && result[i].nodeType === 1) {
+                    elements.push(result[i].outerHTML);
+                }
+            }
+            return elements;
+        }
+
+        // 3. å¤„ç†å•ä¸ª DOM å…ƒç´ 
+        if (result.nodeType === 1) {
+            return result.outerHTML;
+        }
+
+        // 4. æ£€æŸ¥æ˜¯å¦æ˜¯å…·æœ‰æ•°å­—ç´¢å¼•å’Œlengthå±æ€§çš„ç±»æ•°ç»„å¯¹è±¡
+        if (!Array.isArray(result) &&
+            typeof result === 'object' &&
+            'length' in result &&
+            typeof result.length === 'number') {
+
+            // æ£€æŸ¥ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯DOMèŠ‚ç‚¹
+            const firstElement = result[0];
+            if (firstElement && firstElement.nodeType === 1) {
+                const elements = [];
+                const length = Math.min(result.length, 100);
+
+                for (let i = 0; i < length; i++) {
+                    const elem = result[i];
+                    if (elem && elem.nodeType === 1) {
+                        elements.push(elem.outerHTML);
+                    }
+                }
+
+                return elements;
+            }
+        }
+
+        // 5. å¤„ç†æ™®é€šå¯¹è±¡å’Œæ•°ç»„ - ä½¿ç”¨æ ‡å‡†åºåˆ—åŒ–
+        try {
+            return JSON.parse(JSON.stringify(result, function(key, value) {
+                if (typeof value === 'object' && value !== null) {
+                    if (value.nodeType === 1) {
+                        return value.outerHTML;
+                    }
+                    if (value === window || value === document) {
+                        return '[Object]';
+                    }
+                }
+                return value;
+            }));
+        } catch (e) {
+            console.error("åºåˆ—åŒ–å¯¹è±¡å¤±è´¥:", e);
+            return `[æ— æ³•åºåˆ—åŒ–çš„å¯¹è±¡: ${e.message}]`;
+        }
+    }
+
+    // é˜²æ­¢é‡å¤åˆå§‹åŒ–
+    if (window.ljq_init) return;
+    window.ljq_init = true;
+
+    function connecthttp() {
+        if (window.use_ws) return;
+        updateStatus('conn');
+        GM_xmlhttpRequest({
+            method: "POST",
+            url: httpUrl + "api/longpoll",
+            headers: {"Content-Type": "application/json"},
+            data: JSON.stringify({
+                type: 'ready',
+                url: location.href,
+                sessionId: sid
+            }),
+            onload: function(resp) {
+                if (resp.status === 200) {
+                    let data = JSON.parse(resp.responseText);
+                    console.log(log_prefix + 'æ¥æ”¶åˆ°æ•°æ®:', data);
+                    if (data.id === "" && data.ret === "use ws") return;
+                    if (data.id === "") return setTimeout(connecthttp, 100);
+                    const response = executeCode(data);
+
+                    if (response.error) {
+                        handleError(data.id, response.error, 'æ‰§è¡Œä»£ç ');
+                    } else {
+                       GM_xmlhttpRequest({
+                           method: "POST",
+                           url: httpUrl + "api/result",
+                           headers: {"Content-Type": "application/json"},
+                           data: JSON.stringify({
+                               type: 'result',
+                               id: data.id,
+                               sessionId: sid,
+                               result: response.result
+                           })
+                       });
+                    }
+                } else {
+                    console.error(log_prefix + 'è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç ï¼š', resp.status);
+                    updateStatus('err', 'è¯·æ±‚å¤±è´¥');
+                }
+                setTimeout(connecthttp, 1000);
+            },
+            onerror: function(err) {
+                console.error(log_prefix + 'è¯·æ±‚é”™è¯¯', err);
+                updateStatus('err', 'è¯·æ±‚å¤±è´¥');
+                setTimeout(connecthttp, 5000);
+            },
+            ontimeout: function() {
+                console.log(log_prefix + 'è¯·æ±‚è¶…æ—¶');
+                updateStatus('err', 'è¯·æ±‚è¶…æ—¶');
+                setTimeout(connecthttp, 5000);
+            }
+        });
+    }
+
+    function executeCode(data) {
+        let id = data.id || 'unknown'; // è·å– ID
+        let result;
+
+        if (!data.code) {
+            console.log('æ”¶åˆ°éä»£ç æ‰§è¡Œæ¶ˆæ¯:', data);
+            return { error: 'æ²¡æœ‰å¯æ‰§è¡Œçš„ä»£ç ' };
+        }
+        updateStatus('exec');
+
+        try {
+            const jsCode = data.code.trim();
+            const lines = jsCode.split(/\r?\n/).filter(l => l.trim());
+            const lastLine = lines.length > 0 ? lines[lines.length - 1].trim() : '';
+
+            if (lastLine.startsWith('return')) {
+                // æœ€åä¸€è¡ŒåŒ…å« return è¯­å¥ï¼Œä½¿ç”¨ Function æ„é€ å™¨
+                result = (new Function(jsCode))();
+            } else {
+                try {
+                    result = eval(jsCode);
+                } catch (e) {
+                    if (isIllegalReturnError(e)) {
+                        result = (new Function(jsCode))();
+                    } else {
+                        throw e; 
+                    }
+                }
+            }
+            const processedResult = smartProcessResult(result);
+            return { result: processedResult }; 
+
+        } catch (execError) {
+            return { error: execError }; // è¿”å›é”™è¯¯ä¿¡æ¯
+        }
+    }
+
+    function isIllegalReturnError(e) {
+        return e instanceof SyntaxError && (
+            /Illegal return statement/i.test(e.message) ||      // Chrome å¸¸è§
+            /return not in function/i.test(e.message) ||        // Firefox å¸¸è§
+            /Illegal 'return' statement/i.test(e.message)       // å…¼å®¹æ—§æ–‡æ¡ˆ
+        );
+    }
+
+    function connect() {
+        ws = new WebSocket(wsUrl);
+
+        ws.onopen = function() {
+            window.use_ws = true;
+            console.log(log_prefix + 'å·²è¿æ¥');
+            updateStatus('ok');
+            ws.send(JSON.stringify({
+                type: 'ready',
+                url: location.href,
+                sessionId: sid
+            }));
+        };
+
+        ws.onclose = function() {
+            console.log(log_prefix + 'å·²æ–­å¼€ï¼Œ5ç§’åé‡è¿');
+            updateStatus('disc');
+            setTimeout(connect, 5000);
+        };
+
+        ws.onerror = function(err) {
+            console.error(log_prefix + 'è¿æ¥é”™è¯¯', err);
+            updateStatus('err', 'è¿æ¥å¤±è´¥');
+            isWebSocketServerAlive(function (e) { if (e) connecthttp()});
+        };
+
+        ws.onmessage = async function(e) {
+            try {
+                let data = JSON.parse(e.data);
+                let startTime = Date.now();
+                let newTabs = [];
+                let checkNewTab = data.auto_switch_newtab === true;
+                GM_setValue('new_tab_report', null);   
+                const response = executeCode(data);
+             
+                if (response.error) {
+                    handleError(data.id, response.error, 'æ‰§è¡Œä»£ç ');
+                } else {
+                    if (checkNewTab) {
+                        for (let i = 0; i < 10; i++) {
+                            await new Promise(r => setTimeout(r, 150));
+                            let latestReport = GM_getValue('new_tab_report');
+                            if (latestReport && latestReport.ts >= startTime) {
+                                console.log(`%c[Detected] è½®è¯¢ç¬¬ ${i+1} æ¬¡æŠ“åˆ°æ–°æ ‡ç­¾!`, "color: green");
+                                newTabs.push(latestReport);
+                                break; 
+                            }
+                        }
+                    }
+                    updateStatus('ok');  
+                    ws.send(JSON.stringify({
+                        type: 'result',
+                        id: data.id,
+                        sessionId: sid,
+                        result: response.result,
+                        newTabs: newTabs
+                    }));
+                }
+            } catch (parseError) {
+                handleError('unknown', parseError, 'è§£ææ¶ˆæ¯');
+            }
+        };
+
+    }
+
+    // åˆå§‹åŒ–
+    function init() {
+        if (document.body) {
+            getIndicator();
+            connect();
+        } else {
+            setTimeout(init, 50);
+        }
+    }
+
+    // ç›‘æ§DOMå˜åŒ–
+    const observer = new MutationObserver(() => getIndicator());
+
+    if (document.readyState !== 'loading') {
+        init();
+        observer.observe(document.body, { childList: true, subtree: true });
+    } else {
+        document.addEventListener('DOMContentLoaded', () => {
+            init();
+            observer.observe(document.body, { childList: true, subtree: true });
+        });
+    }
+
+    // æ¸…ç†
+    window.addEventListener('beforeunload', () => {
+        observer.disconnect();
+        if (ws && ws.readyState === WebSocket.OPEN) {
+            ws.close();
+        }
+    });
+})();
\ No newline at end of file
diff --git a/make_prompts.py b/make_prompts.py
new file mode 100644
index 0000000..5905083
--- /dev/null
+++ b/make_prompts.py
@@ -0,0 +1,137 @@
+import sys, os, re
+import pyperclip
+import json, time
+from pathlib import Path
+import subprocess
+import tempfile
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+from sidercall import SiderLLMSession, LLMSession, ToolClient
+
+
+ask = SiderLLMSession().ask
+
+
+def generate_tool_schema():
+    """
+    é€šè¿‡ä»£ç å†…çœï¼Œå°† Handler çš„é€»è¾‘æ˜ å°„ä¸ºé«˜è¯­ä¹‰çš„å·¥å…·æè¿°ã€‚
+    """
+    with open('ga.py', 'r', encoding='utf-8') as f:
+        ga_code = f.read()
+    # æç®€ä¸”å…·å¤‡é«˜åº¦æ¦‚æ‹¬èƒ½åŠ›çš„å…ƒ Prompt
+    meta_prompt = f"""
+# Role
+ä½ æ˜¯ä¸€ä¸ªå…·å¤‡æ·±åº¦æ¨ç†èƒ½åŠ›çš„ AI ç³»ç»Ÿæ¶æ„å¸ˆã€‚ä½ å°†é€šè¿‡é˜…è¯» `GenericAgentHandler` æºç ï¼Œæ„å»ºå…¶å¯¹åº”çš„å·¥å…·èƒ½åŠ›çŸ©é˜µã€‚
+
+# Task
+åˆ†æä¸‹æ–¹çš„æºç ï¼Œå¹¶è¾“å‡º OpenAI Tool Schemaã€‚åœ¨è¾“å‡º JSON ä¹‹å‰ï¼Œä½ å¿…é¡»è¿›è¡Œå†…éƒ¨æ€è€ƒï¼ˆThinking Processï¼‰ã€‚
+
+# Thinking Process Requirements
+åœ¨ `<thinking>` æ ‡ç­¾ä¸­ï¼Œè¯·æŒ‰é¡ºåºåˆ†æï¼š
+1. **æ ¸å¿ƒå·¥å…·é“¾è¯†åˆ«**ï¼šè¯†åˆ«æ‰€æœ‰ `do_xxx` æ–¹æ³•ï¼Œå¹¶åˆ†æå®ƒä»¬ä¾èµ–çš„åº•å±‚ Utility å‡½æ•°ã€‚
+2. **å†…å®¹æº¯æºå®¡è®¡**ï¼šé‡ç‚¹åˆ†æå“ªäº›å·¥å…·æ˜¯ä» `response.content` æå–æ ¸å¿ƒé€»è¾‘ï¼ˆå¦‚ä»£ç å—ï¼‰çš„ã€‚å¯¹äºè¿™äº›å·¥å…·ï¼Œç¡®è®¤åœ¨ Schema å‚æ•°ä¸­æ’é™¤æ‰å¯¹åº”çš„å­—æ®µã€‚
+3. **è°ƒç”¨ç­–ç•¥æ¨å¯¼**ï¼šåˆ†æå·¥å…·é—´çš„åä½œå…³ç³»ï¼ˆä¾‹å¦‚ `file_read` å¦‚ä½•ä¸º `file_patch` æä¾›å®šä½ï¼‰ã€‚
+4. **å…œåº•é€»è¾‘ç¡®è®¤**ï¼šæ˜ç¡®æŸäº›ç‰¹æ®Šä¸‡èƒ½å·¥å…·åœ¨ç³»ç»Ÿä¸­çš„ä¿åº•è§’è‰²ï¼Œå¿«é€Ÿå·¥å…·æ— æ³•æ‰§è¡Œçš„æ“ä½œç”±ä¿åº•å·¥å…·æ‰§è¡Œï¼Œä½†æ­£å¸¸åº”ä¼˜å…ˆä½¿ç”¨æ–¹ä¾¿çš„å·¥å…·ã€‚
+5. **æ³¨é‡Šå®¡é˜…**ï¼šç»“åˆå‡½æ•°æ³¨é‡Šï¼Œç†è§£æ¯ä¸ªå·¥å…·çš„ä½¿ç”¨é™åˆ¶ï¼Œå…¶ä¸­çš„é‡è¦ä¿¡æ¯åŠ¡å¿…åæ˜ åœ¨å·¥å…·æè¿°ä¸­ï¼ˆå¦‚é•¿åº¦é™åˆ¶ç­‰ï¼‰ã€‚
+æ³¨é‡Šä¸­çš„é‡è¦ä¿¡æ¯åŠ¡å¿…åæ˜ åœ¨å·¥å…·æè¿°ä¸­ã€‚
+æ³¨é‡Šä¸­çš„é‡è¦ä¿¡æ¯åŠ¡å¿…åæ˜ åœ¨å·¥å…·æè¿°ä¸­ã€‚
+
+# Tool Schema Formatting Rules
+- **å‚æ•°å¯¹é½**ï¼šä»…åŒ…å« `do_xxx` æ–¹æ³•ä¸­é€šè¿‡ `args.get()` æ˜¾å¼è·å–çš„å‚æ•°ã€‚
+- **é«˜å¼•å¯¼æ€§æè¿°**ï¼šæè¿°åº”åŒ…å«â€œä½•æ—¶è°ƒç”¨â€ä»¥åŠâ€œå¦‚ä½•æ ¹æ®åé¦ˆä¿®æ­£â€ï¼Œéœ€è¦æ³¨æ„å‡½æ•°çš„æ³¨é‡Šäº‹é¡¹ã€‚
+- **è¾“å‡ºæ ¼å¼**ï¼šå…ˆè¾“å‡º `<thinking>` å—ï¼Œç„¶åè¾“å‡º ```json å—ã€‚
+
+# Source Code
+{ga_code}
+
+# Output
+è¯·å¼€å§‹æ€è€ƒå¹¶ç”Ÿæˆï¼š
+"""
+    
+    # å‡è®¾ ask æ˜¯ä½ å·²ç»å°è£…å¥½çš„ LLM è°ƒç”¨æ¥å£
+    raw_response = ask(meta_prompt, model="gemini-3.0-flash")
+    print(raw_response)
+    
+    # --- å¥å£®çš„ JSON è§£æé€»è¾‘ ---
+    try:
+        # 1. æ¸…é™¤ Markdown å›´æ 
+        clean_json = raw_response.strip()
+        if clean_json.startswith("```"):
+            # å…¼å®¹ ```json å’Œ ``` 
+            clean_json = re.sub(r'^```(?:json)?\s*', '', clean_json)
+            clean_json = re.sub(r'\s*```$', '', clean_json)
+        
+        # 2. ç§»é™¤å¯èƒ½çš„é JSON å‰å¯¼/åç¼€æ–‡å­—ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
+        start_idx = clean_json.find('[')
+        end_idx = clean_json.rfind(']') + 1
+        if start_idx != -1 and end_idx != -1:
+            clean_json = clean_json[start_idx:end_idx]
+            
+        final_schema = json.loads(clean_json)
+        
+        if final_schema:
+            with open('tools_schema.json', 'w', encoding='utf-8') as f:
+                json.dump(final_schema, f, indent=2, ensure_ascii=False)
+            print("âœ… æˆåŠŸä»ä»£ç å†…çœç”Ÿæˆ Schema å¹¶æŒä¹…åŒ–ã€‚")
+        return final_schema
+
+    except Exception as e:
+        print(f"âŒ è§£æ Schema å¤±è´¥: {e}\nåŸå§‹å“åº”: {raw_response}")
+        return None
+
+
+def make_system_prompt(ga_code_path='ga.py'):
+    with open(ga_code_path, 'r', encoding='utf-8') as f:
+        ga_code = f.read()
+
+    # è¿™ä¸ªå…ƒ Prompt çš„ç›®æ ‡æ˜¯ç”Ÿæˆâ€œä¸–ç•Œè§‚â€è€Œéâ€œè¯´æ˜ä¹¦â€
+    meta_prompt = f"""
+# Role
+ä½ æ˜¯ä¸€ä¸ª AI æ¶æ„å¸ˆã€‚è¯·é˜…è¯»ä¸‹æ–¹çš„å·¥å…·åº“æºç ï¼Œä¸º Agent ç”Ÿæˆä¸€ä»½ã€ç³»ç»Ÿçº§è®¤çŸ¥æŒ‡ä»¤ (System Prompt)ã€‘ã€‚
+
+# Task
+åŸºäºä»£ç é€»è¾‘ï¼Œå®šä¹‰ Agent çš„â€œèƒ½åŠ›è¾¹ç•Œâ€å’Œâ€œè¡ŒåŠ¨åè®®â€ã€‚
+
+# Requirements (Crucial)
+1. **æ‰“ç ´é¢„è®­ç»ƒåè§**ï¼šé’ˆå¯¹æ¨¡å‹å¸¸è¯´çš„â€œæˆ‘åªæ˜¯ AIï¼Œä¸èƒ½æ“ä½œç½‘é¡µ/æ–‡ä»¶â€è¿›è¡Œä¿®æ­£ã€‚æ˜ç¡®å‘Šè¯‰å®ƒï¼šä½ ç°åœ¨æ‹¥æœ‰ç‰©ç†æ“ä½œæƒé™ï¼Œå·¥å…·è®¾è®¡ä¿è¯äº†æ‰€æœ‰æƒé™åšæ‰€æœ‰äº‹æƒ…ã€‚
+2. **é¿å¼€å†—ä½™**ï¼šä¸è¦é‡å¤ Tool Schema é‡Œçš„å‚æ•°ç»†èŠ‚ã€‚
+3. **èƒ½åŠ›è¾¹ç•Œå®šä¹‰**ï¼š
+   - ç½‘é¡µæ“ä½œï¼šå®ƒä¸æ˜¯é€šè¿‡â€œæƒ³è±¡â€ä¸Šç½‘ï¼Œè€Œæ˜¯é€šè¿‡å®æ—¶çš„æµè§ˆå™¨è¯»å†™ã€‚
+   - æ–‡ä»¶æ“ä½œï¼šå®ƒæ‹¥æœ‰ç‰©ç†æ–‡ä»¶è¯»å†™æƒé™ï¼Œä¸”éµå¾ªâ€œå…ˆè¯»åå†™â€çš„ç¨³å¥æ€§åŸåˆ™ã€‚
+   - ä¿åº•é€»è¾‘ï¼šå½“ä¸“ç”¨å·¥å…·å¤±æ•ˆæ—¶ï¼Œä½¿ç”¨ `code_run` ç¼–å†™è„šæœ¬è§£å†³ä¸€åˆ‡ã€‚
+   - ç‰¹æ®Šçš„update_planï¼ˆä»…åœ¨å¤æ‚ä»»åŠ¡æ—¶ä½¿ç”¨ï¼‰å’Œask_userï¼ˆç”¨æˆ·ä¹Ÿæ˜¯æœ‰æ•ˆèµ„æºï¼‰å·¥å…·ã€‚
+4. **è¡ŒåŠ¨åè®®**ï¼š
+   - å¿…é¡»åœ¨è¡ŒåŠ¨å‰è¿›è¡Œ<thinking>
+
+æˆ‘åé¢è¿˜ä¼šé™„ä¸Šå…·ä½“çš„å·¥å…·æè¿°å’ŒSchemaï¼Œæ‰€ä»¥ä¸è¦é‡å¤ã€‚
+ä¸»è¦ä»¥ä¸–ç•Œè§‚ä¸ºä¸»ï¼Œä¸è¦çº ç»“äºå…·ä½“å·¥å…·ã€‚
+
+# Input Source Code
+{ga_code}
+
+# Output
+ä»…è¾“å‡º System Prompt çš„æ­£æ–‡ï¼Œè¯­æ°”è¦æœæ–­ã€æŒ‡ä»¤åŒ–ã€‚
+"""
+    print("ğŸ§  æ­£åœ¨é‡å¡‘ Agent ä¸–ç•Œè§‚ (Generating System Prompt)...")
+    # è°ƒç”¨ä½ çš„ llmclient.ask
+    system_prompt_content = ask(meta_prompt)
+    print("ğŸ“ ç”Ÿæˆçš„ System Prompt å†…å®¹å¦‚ä¸‹ï¼š\n")
+    print(system_prompt_content)
+    clean_content = re.sub(r'<[^>]+>', '', system_prompt_content)
+    with open('sys_prompt.txt', 'w', encoding='utf-8') as f:
+        f.write(clean_content)
+    return clean_content
+
+# --- ä¸»é€»è¾‘ ---
+if __name__ == "__main__":
+    if len(sys.argv) < 2:
+        print("Usage: python make_prompts.py [schema|prompt]")
+        sys.exit(1)
+    
+    cmd = sys.argv[1].lower()
+    if cmd == "schema":
+        generate_tool_schema()
+    elif cmd == "prompt":
+        make_system_prompt()
+    else:
+        print(f"Unknown command: {cmd}")
+        print("Available commands: schema, prompt")
\ No newline at end of file
diff --git a/sidercall.py b/sidercall.py
new file mode 100644
index 0000000..706c686
--- /dev/null
+++ b/sidercall.py
@@ -0,0 +1,179 @@
+import os, json, re, time, requests
+from sider_ai_api import Session
+
+try:
+    from mykey import sider_cookie, capikey
+except ImportError:
+    sider_cookie = ""
+    capikey = ""
+
+class SiderLLMSession:
+    def __init__(self, multiturns=6):
+        self._core = Session(cookie=sider_cookie, proxies={'https':'127.0.0.1:2082'})   
+    def ask(self, prompt, model="gemini-3.0-flash"):
+        if len(prompt) > 30000: prompt = prompt[-29500:]
+        return ''.join(self._core.chat(prompt, model))
+  
+class LLMSession:
+    def __init__(self, api_key=capikey, api_base="http://113.45.39.247:3001/v1", multiturns=6):
+        self.api_key = api_key
+        self.api_base = api_base
+        self.messages = []
+        self.multiturns = multiturns
+        
+    def ask(self, prompt, model="openai/gpt-5.1"):
+        self.messages.append({"role": "user", "content": prompt})
+        if len(self.messages) > self.multiturns:
+            self.messages = self.messages[-self.multiturns:]
+        headers = {
+            "Authorization": f"Bearer {self.api_key}",
+            "Content-Type": "application/json"
+        }
+        try:
+            response = requests.post(
+                f"{self.api_base}/chat/completions",
+                headers=headers,
+                json={
+                    "model": model, 
+                    "messages": self.messages, 
+                    "temperature": 0.5
+                },
+                timeout=60
+            )
+            res_json = response.json()
+            content = res_json["choices"][0]["message"]["content"]
+            self.messages.append({"role": "assistant", "content": content})
+            return content
+        except Exception as e:
+            return f"Error: {str(e)}"
+
+class MockFunction:
+    def __init__(self, name, arguments):
+        self.name = name
+        self.arguments = arguments  
+
+class MockToolCall:
+    def __init__(self, name, args):
+        arg_str = json.dumps(args, ensure_ascii=False) if isinstance(args, dict) else args
+        self.function = MockFunction(name, arg_str)
+
+class MockResponse:
+    def __init__(self, thinking, content, tool_calls, raw):
+        self.thinking = thinking        # å­˜æ”¾ <thinking> å†…éƒ¨çš„æ€ç»´è¿‡ç¨‹
+        self.content = content          # å­˜æ”¾å»é™¤æ ‡ç­¾åçš„çº¯æ–‡æœ¬å›å¤
+        self.tool_calls = tool_calls    # å­˜æ”¾ MockToolCall åˆ—è¡¨ æˆ– None
+        self.raw = raw
+    def __repr__(self):    
+        return f"<MockResponse thinking={bool(self.thinking)}, content='{self.content}', tools={bool(self.tool_calls)}>"
+
+class ToolClient:
+    def __init__(self, raw_api_func, auto_save_tokens=False):
+        self.raw_api = raw_api_func
+        self.auto_save_tokens = auto_save_tokens
+        self.last_tools = ''
+        self.total_cd_tokens = 0
+
+    def chat(self, messages, tools=None):
+        full_prompt = self._build_protocol_prompt(messages, tools)      
+        print("Full prompt length:", len(full_prompt))
+        raw_text = self.raw_api(full_prompt)
+        with open('model_responses.txt', 'a', encoding='utf-8', errors="replace") as f:
+            f.write(f"=== Prompt ===\n{full_prompt}\n=== Response ===\n{raw_text}\n\n")
+        return self._parse_mixed_response(raw_text)
+
+    def _build_protocol_prompt(self, messages, tools):
+        system_content = next((m['content'] for m in messages if m['role'].lower() == 'system'), "ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½åŠ©æ‰‹ã€‚")
+        history_msgs = [m for m in messages if m['role'].lower() != 'system']
+        
+        # æ„é€ å·¥å…·æè¿°
+        tool_instruction = ""
+        if tools:
+            tools_json = json.dumps(tools, ensure_ascii=False, indent=2)
+            tool_instruction = f"""
+### âš¡ï¸ äº¤äº’åè®® (å¿…é¡»ä¸¥æ ¼éµå®ˆ)
+è¯·æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤æ€è€ƒå¹¶è¡ŒåŠ¨ï¼š
+1. **æ€è€ƒ**: åœ¨ `<thinking>` æ ‡ç­¾ä¸­åˆ†æç°çŠ¶å’Œç­–ç•¥ã€‚
+2. **è¡ŒåŠ¨**: å¦‚æœéœ€è¦è°ƒç”¨å·¥å…·ï¼Œè¯·ç´§æ¥ç€è¾“å‡ºä¸€ä¸ª **<tool_use>å—**ï¼Œç„¶åç»“æŸï¼Œæˆ‘ä¼šç¨åç»™ä½ è¿”å›<tool_result>å—ã€‚
+   æ ¼å¼: ```<tool_use>\n{{"function": "å·¥å…·å", "arguments": {{å‚æ•°}}}}\n</tool_use>\n```
+
+### ğŸ› ï¸ å¯ç”¨å·¥å…·åº“
+{tools_json}
+"""
+            if self.auto_save_tokens and self.last_tools == tools_json:
+                tool_instruction = "\n### âš¡ï¸ äº¤äº’åè®®ä¿æŒä¸å˜ï¼Œç»§ç»­ä½¿ç”¨ä¹‹å‰çš„å·¥å…·åº“ã€‚\n"
+            else:
+                self.total_cd_tokens = 0
+            self.last_tools = tools_json
+            
+        prompt = f"=== SYSTEM ===\n{system_content}\n{tool_instruction}\n\n"
+        for m in history_msgs:
+            role = "USER" if m['role'] == 'user' else "ASSISTANT"
+            prompt += f"=== {role} ===\n{m['content']}\n\n"
+            
+        self.total_cd_tokens += len(prompt)
+        if self.total_cd_tokens > 6000: self.last_tools = ''
+
+        prompt += "=== ASSISTANT ===\n" 
+        return prompt
+
+    def _parse_mixed_response(self, text):
+        remaining_text = text
+        thinking = ''
+        think_pattern = r"<thinking>(.*?)</thinking>"
+        think_match = re.search(think_pattern, text, re.DOTALL)
+        
+        if think_match:
+            thinking = think_match.group(1).strip()
+            remaining_text = re.sub(think_pattern, "", remaining_text, flags=re.DOTALL)
+        
+        tool_calls = None
+        tool_pattern = r"<tool_use>(.*?)</tool_use>"
+        tool_match = re.search(tool_pattern, text, re.DOTALL)
+        
+        json_str = ""
+        if tool_match:
+            json_str = tool_match.group(1).strip()
+            remaining_text = re.sub(tool_pattern, "", remaining_text, flags=re.DOTALL)
+        elif '<tool_use>' in remaining_text:
+            weaktoolstr = remaining_text.split('<tool_use>')[-1].strip()
+            json_str = weaktoolstr if weaktoolstr.endswith('}') else ''
+            remaining_text = remaining_text.replace('<tool_use>'+weaktoolstr, "")
+
+        if json_str:
+            try:
+                data = tryparse(json_str)
+                func_name = data.get('function') or data.get('tool')
+                args = data.get('arguments') or data.get('args')
+                if args is None: args = {}
+                if func_name: tool_calls = [MockToolCall(func_name, args)]
+            except json.JSONDecodeError:
+                print("[Warn] Failed to parse tool_use JSON:", json_str)
+                thinking += f"[Warn] JSON è§£æå¤±è´¥ï¼Œæ¨¡å‹è¾“å‡ºäº†æ— æ•ˆçš„ JSON."
+
+        content = remaining_text.strip()
+        if not content: content = ""
+        return MockResponse(thinking, content, tool_calls, text)
+
+def tryparse(json_str):
+    try: return json.loads(json_str)
+    except:
+        return json.loads(json_str[:-1])
+
+if __name__ == "__main__":
+    llmclient = ToolClient(LLMSession().ask)
+    response = llmclient.chat(
+        messages=[{"role": "user", "content": "æˆ‘çš„IPæ˜¯å¤šå°‘"}], 
+        tools=[{"name": "get_ip", "parameters": {}}]
+    )
+    # 4. è·å–ç»“æœ
+    print(f"æ€è€ƒ: {response.thinking}") 
+    # -> æˆ‘éœ€è¦æŸ¥ä¸€ä¸‹ IPã€‚
+
+    if response.tool_calls:
+        cmd = response.tool_calls[0]
+        print(f"è°ƒç”¨: {cmd.function.name} å‚æ•°: {cmd.function.arguments}")
+
+    response = llmclient.chat(
+        messages=[{"role": "user", "content": "<tool_result>10.176.45.12</tool_result>"}] 
+    )
+    print(response.content)
\ No newline at end of file
diff --git a/simphtml.py b/simphtml.py
new file mode 100644
index 0000000..d555460
--- /dev/null
+++ b/simphtml.py
@@ -0,0 +1,862 @@
+from bs4 import BeautifulSoup
+
+js_optHTML = '''function optHTML() {
+function createEnhancedDOMCopy() {  
+  const nodeInfo = new WeakMap();  
+  const ignoreTags = ['SCRIPT', 'STYLE', 'NOSCRIPT', 'META', 'LINK', 'COLGROUP', 'COL', 'TEMPLATE', 'PARAM', 'SOURCE'];  
+  const ignoreIds = ['ljq-ind'];  
+  function cloneNode(sourceNode, keep=false) {  
+    if (sourceNode.nodeType === 8 ||   
+        (sourceNode.nodeType === 1 && (  
+          ignoreTags.includes(sourceNode.tagName) ||   
+          (sourceNode.id && ignoreIds.includes(sourceNode.id))  
+        ))) {  
+      return null;  
+    }  
+    if (sourceNode.nodeType === 3) return sourceNode.cloneNode(false);  
+    const clone = sourceNode.cloneNode(false);  
+
+    const isDropdown = sourceNode.classList?.contains('dropdown-menu') ||   
+             /dropdown|menu/i.test(sourceNode.className) || sourceNode.getAttribute('role') === 'menu'; 
+    const isSmallDropdown = isDropdown && (sourceNode.querySelectorAll('a, button, [role="menuitem"], li').length <= 7 && sourceNode.textContent.length < 500);  
+
+    const childNodes = [];  
+    for (const child of sourceNode.childNodes) {  
+      const childClone = cloneNode(child, keep || isSmallDropdown);  
+      if (childClone) childNodes.push(childClone);  
+    }  
+
+    const rect = sourceNode.getBoundingClientRect();
+    const style = window.getComputedStyle(sourceNode);
+    const area = (style.display === 'none' || style.visibility === 'hidden' || parseFloat(style.opacity) <= 0)?0:rect.width * rect.height;
+    const isVisible = (rect.width > 1 && rect.height > 1 &&   
+                  style.display !== 'none' && style.visibility !== 'hidden' &&   
+                  parseFloat(style.opacity) > 0 &&  
+                  Math.abs(rect.left) < 5000 && Math.abs(rect.top) < 5000) 
+                  || isSmallDropdown;  
+    const zIndex = style.position !== 'static' ? (parseInt(style.zIndex) || 0) : 0;
+  
+    let info = {
+          rect, area, isVisible, isSmallDropdown, zIndex,
+          style: {  
+            display: style.display, visibility: style.visibility,  
+            opacity: style.opacity, position: style.position
+          }};
+    
+    const nonTextChildren = childNodes.filter(child => child.nodeType !== 3);  
+    const hasValidChildren = nonTextChildren.length > 0;  
+          
+    if (!isVisible && nonTextChildren.length > 0) {
+      const visChild = nonTextChildren.find(child => 
+          nodeInfo.has(child) && nodeInfo.get(child).isVisible);
+      if (visChild) info = nodeInfo.get(visChild);
+    }
+    nodeInfo.set(clone, info);
+
+    if (sourceNode.nodeType === 1 && sourceNode.tagName === 'DIV') {    
+      if (!hasValidChildren && !sourceNode.textContent.trim()) return null; 
+    }  
+    if (info.isVisible || hasValidChildren || keep) {  
+      childNodes.forEach(child => clone.appendChild(child));  
+      return clone;  
+    }  
+    return null;  
+  }  
+  
+  return {  
+    domCopy: cloneNode(document.body),  
+    getNodeInfo: node => nodeInfo.get(node),  
+    isVisible: node => {  
+      const info = nodeInfo.get(node);  
+      return info && info.isVisible;  
+    }  
+  };  
+}  
+const { domCopy, getNodeInfo, isVisible } = createEnhancedDOMCopy();  
+const viewportArea = window.innerWidth * window.innerHeight; 
+
+function analyzeNode(node, pPathType='main') {  
+    // å¤„ç†éå…ƒç´ èŠ‚ç‚¹å’Œå¶èŠ‚ç‚¹  
+    if (node.nodeType !== 1 || !node.children.length) {  
+      node.nodeType === 1 && (node.dataset.mark = 'K:leaf');  
+      return;  
+    }  
+    const pathType = (node.dataset.mark && !node.dataset.mark.includes(':main')) ? 'second' : pPathType;  
+    const rectn = getNodeInfo(node).rect; 
+    if (rectn.width < window.innerWidth * 0.8 && rectn.height < window.innerHeight * 0.8) return node;
+    if (node.tagName === 'TABLE') return;
+    const children = Array.from(node.children);  
+    if (children.length === 1) {  
+      node.dataset.mark = 'K:container';  
+      return analyzeNode(children[0], pathType);  
+    }  
+    if (children.length > 10) return;
+    
+    // è·å–å­å…ƒç´ ä¿¡æ¯å¹¶æ’åº  
+    const childrenInfo = children.map(child => {  
+      const info = getNodeInfo(child) || { rect: {}, style: {} };  
+      return { node: child, rect: info.rect, style: info.style, 
+          area: info.area, zIndex: info.zIndex };  
+    }).sort((a, b) => b.area - a.area);  
+    
+    // æ£€æµ‹æ˜¯åˆ’åˆ†è¿˜æ˜¯è¦†ç›–  
+    const isOverlay = hasOverlap(childrenInfo);  
+    node.dataset.mark = isOverlay ? 'K:overlayParent' : 'K:partitionParent';  
+    
+    if (isOverlay) handleOverlayContainer(childrenInfo, pathType);  
+    else handlePartitionContainer(childrenInfo, pathType);  
+
+    console.log(`${isOverlay ? 'è¦†ç›–' : 'åˆ’åˆ†'}å®¹å™¨:`, node, `å­å…ƒç´ æ•°é‡: ${children.length}`);  
+    console.log('å­å…ƒç´ åŠæ ‡è®°:', children.map(child => ({   
+      element: child,   
+      mark: child.dataset.mark || 'æ— ',  
+      info: getNodeInfo ? getNodeInfo(child) : undefined  
+    })));  
+    for (const child of children)  
+      if (!child.dataset.mark || child.dataset.mark[0] !== 'R') analyzeNode(child, pathType);  
+  }  
+  
+  // å¤„ç†åˆ’åˆ†å®¹å™¨  
+  function handlePartitionContainer(childrenInfo, pathType) {  
+    childrenInfo.sort((a, b) => b.area - a.area);
+    const totalArea = childrenInfo.reduce((sum, item) => sum + item.area, 0);  
+    console.log(childrenInfo[0].area / totalArea);
+    const hasMainElement = childrenInfo.length >= 1 &&   
+                          (childrenInfo[0].area / totalArea > 0.5) &&   
+                          (childrenInfo.length === 1 || childrenInfo[0].area > childrenInfo[1].area * 2);  
+    if (hasMainElement) {  
+      childrenInfo[0].node.dataset.mark = 'K:main';
+      for (let i = pathType==='main'?1:0; i < childrenInfo.length; i++) {  
+        const child = childrenInfo[i];  
+        let isSecondary = containsButton(child.node);
+        if (pathType === "main" && child.node.className.toLowerCase().includes('nav')) isSecondary = true;
+        if (pathType === "main" && child.node.className.toLowerCase().includes('breadcrumbs')) isSecondary = true;
+        if (pathType === "main" && child.node.className.toLowerCase().includes('header') && child.node.className.toLowerCase().includes('table')) isSecondary = true;
+        if (pathType === "main" && child.node.innerHTML.trim().replace(/\s+/g, '').length < 500) isSecondary = true;
+        if (child.style.visibility === 'hidden') isSecondary = false;
+        if (isSecondary) child.node.dataset.mark = 'K:secondary';  
+        else child.node.dataset.mark = 'R:nonEssential';  
+      }  
+    } else {  
+      const uniqueClassNames = new Set(childrenInfo.map(item => item.node.className)).size;  
+      const highClassNameVariety = uniqueClassNames >= childrenInfo.length * 0.8;  
+      if (pathType !== 'main' && highClassNameVariety && childrenInfo.length > 5) {
+        childrenInfo.forEach(child => child.node.dataset.mark = 'R:equalmany');  
+      } else {
+        childrenInfo.forEach(child => child.node.dataset.mark = 'K:equal');  
+      }
+    }  
+  }  
+
+  function containsButton(container) {  
+    const hasStandardButton = container.querySelector('button, input[type="button"], input[type="submit"], [role="button"]') !== null;  
+    if (hasStandardButton) return true;  
+    const hasClassButton = container.querySelector('[class*="-btn"], [class*="-button"], .button, .btn, [class*="btn-"]') !== null;  
+    return hasStandardButton || hasClassButton;  
+  }   
+  
+  function handleOverlayContainer(childrenInfo, pathType) {  
+    const sorted = [...childrenInfo].sort((a, b) => b.zIndex - a.zIndex);  
+    console.log('æ’åºåçš„å­å…ƒç´ :', sorted);
+    if (sorted.length === 0) return;  
+    
+    const top = sorted[0];  
+    const rect = top.rect;  
+    const topNode = top.node; 
+    const isComplex = top.node.querySelectorAll('input, select, textarea, button, a, [role="button"]').length >= 1;  
+
+    const textContent = topNode.textContent?.trim() || '';  
+    const textLength = textContent.length;  
+    const hasLinks = topNode.querySelectorAll('a').length > 0;  
+    const isMostlyText = textLength > 7 && !hasLinks;  
+
+    const centerDiff = Math.abs((rect.left + rect.width/2) - window.innerWidth/2) / window.innerWidth;  
+    const minDimensionRatio = Math.min(rect.width / window.innerWidth, rect.height / window.innerHeight);  
+    const maxDimensionRatio = Math.max(rect.width / window.innerWidth, rect.height / window.innerHeight);  
+    const isNearTop = rect.top < 50;  
+    const isDialog = top.node.querySelector('iframe') && centerDiff < 0.3;
+
+    if (isComplex && centerDiff < 0.2 && 
+        ((minDimensionRatio > 0.2 && rect.width/window.innerWidth < 0.98) || minDimensionRatio > 0.95)) {  
+      top.node.dataset.mark = 'K:mainInteractive';  
+       sorted.slice(1).forEach(e => {
+          if (e.zIndex < sorted[0].zIndex) {
+              e.node.dataset.mark = 'R:covered';
+          } else {
+              e.node.dataset.mark = 'K:noncovered';
+          }
+      });
+    } else {
+      if (isComplex && isNearTop && maxDimensionRatio > 0.4 && top.isVisible) {
+        top.node.dataset.mark = 'K:topBar';
+      } else if (isMostlyText || isComplex || isDialog) {  
+        topNode.dataset.mark = 'K:messageContent'; 
+      } else {  
+        topNode.dataset.mark = 'R:floatingAd'; 
+      }  
+      const rest = sorted.slice(1);  
+      rest.length && (!hasOverlap(rest) ? handlePartitionContainer(rest, pathType) : handleOverlayContainer(rest, pathType));  
+    } 
+  }  
+
+  function isValidInteractiveElement(info) {  
+    const { node, rect, style } = info;  
+    const isCentered = Math.abs((rect.left + rect.width/2) - window.innerWidth/2) < window.innerWidth*0.3;  
+    const isVisible = parseFloat(style.opacity) > 0.1;  
+    const isProminent = (parseInt(info.zIndex) > 30 || style.boxShadow !== 'none');  
+    const hasInteractiveElements = node.querySelector('button, a, input') !== null;  
+    return isCentered && isVisible && isProminent && hasInteractiveElements;  
+  }  
+    
+  function hasOverlap(items) {  
+    return items.some((a, i) =>   
+      items.slice(i+1).some(b => {  
+        const r1 = a.rect, r2 = b.rect;  
+        if (!r1.width || !r2.width || !r1.height || !r2.height) {return false;}
+        const epsilon = 1;
+        return !(r1.x + r1.width <= r2.x + epsilon || r1.x >= r2.x + r2.width - epsilon || 
+            r1.y + r1.height <= r2.y + epsilon || r1.y >= r2.y + r2.height - epsilon
+        );
+      })
+    );  
+}
+
+const result = analyzeNode(domCopy); 
+domCopy.querySelectorAll('[data-mark^="R:"]').forEach(el=>el.parentNode?.removeChild(el));  
+let root = domCopy;  
+while (root.children.length === 1) {  
+  root = root.children[0];  
+}  
+for (let ii = 0; ii < 3; ii++) 
+  root.querySelectorAll('div').forEach(div => (!div.textContent.trim() && div.children.length === 0) && div.remove());
+root.querySelectorAll('[data-mark]').forEach(e => e.removeAttribute('data-mark'));  
+root.removeAttribute('data-mark');  
+return root.outerHTML;
+    }
+optHTML()'''
+
+
+
+js_findMainList = '''function findMainList(startElement = null) {
+        const containerElement = startElement || document.body;  
+        const rect = containerElement.getBoundingClientRect();  
+        const centerX = startElement ? (rect.left + rect.width/2) : (window.innerWidth/2);  
+        const centerY = startElement ? (rect.top + rect.height/2) : (window.innerHeight/2);  
+        
+        // è·å–ä¸­å¿ƒå…ƒç´   
+        const centerElement = document.elementFromPoint(centerX, centerY) || containerElement;  
+        if (!centerElement) return { container: null, items: [] };  
+
+        // æ”¶é›†ç¥–å…ˆé“¾  
+        const ancestors = [];  
+        for (let current = centerElement; current && ancestors.length < 10; current = current.parentElement) {  
+            ancestors.push(current);  
+            if (current === containerElement) break;  
+            if (containerElement !== document.body && !containerElement.contains(current)) break;  
+        }  
+        if (!ancestors.includes(containerElement)) ancestors.push(containerElement);  
+
+        let groupCandidates = [];
+        ancestors.forEach(ancestor => {
+            const topGroups = findTopGroups(ancestor, 3);
+            groupCandidates = groupCandidates.concat(topGroups);
+        });
+
+        console.log(groupCandidates);
+
+        let candidates = [];
+        ancestors.forEach(container => {
+            groupCandidates.forEach(groupInfo => {
+                // å°è¯•å°†ç»„åº”ç”¨åˆ°å½“å‰å®¹å™¨
+                const items = findMatchingElements(container, groupInfo.selector);
+                // åªè€ƒè™‘è¶³å¤Ÿå¤§çš„ç»„
+                if (items.length >= 3) {
+                    candidates.push({
+                        container: container,
+                        selector: groupInfo.selector,
+                        items: items,
+                        gscore: groupInfo.score
+                    });
+                }
+            });
+        });
+
+        candidates = candidates.map(candidate => {
+            const score = scoreContainer(candidate.container, candidate.items) + candidate.gscore;
+            return {...candidate, score};
+        });
+
+        if (candidates.length === 0) {
+            return { container: centerElement, items: [] };
+        }
+
+        // 3. é€‰æ‹©å¾—åˆ†æœ€é«˜çš„å®¹å™¨
+        const bestCandidate = candidates.sort((a, b) => b.score - a.score)[0];
+        console.log(candidates);
+
+        // å¦‚æœæœ€é«˜åˆ†ä»ç„¶å¾ˆä½ï¼Œé€€å›åˆ°ä¸­å¿ƒå…ƒç´ 
+        if (bestCandidate.score < 30) {
+            return { container: centerElement, items: [] };
+        }
+
+        return {
+            container: bestCandidate.container,
+            items: bestCandidate.items,
+            selector: bestCandidate.selector,
+            score: bestCandidate.score
+        };
+    }
+    
+    function findTopGroups(container, limit) {
+        const children = Array.from(container.children);
+        const totalChildren = children.length;
+        if (totalChildren < 3) return [];
+
+        const minGroupSize = Math.max(3, Math.floor(totalChildren * 0.2));
+        const groups = [];
+
+        // ç»Ÿè®¡æ ‡ç­¾å’Œç±»å
+        const tagFreq = {}, classFreq = {}, tagMap = {}, classMap = {};
+
+        children.forEach(child => {
+            // ç»Ÿè®¡æ ‡ç­¾
+            const tag = child.tagName.toLowerCase();
+            if (tag === "td") return;
+            tagFreq[tag] = (tagFreq[tag] || 0) + 1;
+            if (!tagMap[tag]) tagMap[tag] = [];
+            tagMap[tag].push(child);
+
+            // ç»Ÿè®¡ç±»å
+            if (child.className) {
+                child.className.trim().split(/\s+/).forEach(cls => {
+                    if (cls) {
+                        classFreq[cls] = (classFreq[cls] || 0) + 1;
+                        if (!classMap[cls]) classMap[cls] = [];
+                        classMap[cls].push(child);
+                    }
+                });
+            }
+        });
+
+        // è¯„åˆ†å‡½æ•°
+        const scoreGroup = (selector, elements) => {
+            const coverage = elements.length / totalChildren;
+            let specificity = selector.startsWith('.')
+            ? (0.6 + (selector.match(/\./g).length - 1) * 0.1) // ç±»é€‰æ‹©å™¨
+            : (selector.includes('.')
+               ? (0.7 + (selector.match(/\./g).length) * 0.1) // æ ‡ç­¾+ç±»
+               : 0.3); // çº¯æ ‡ç­¾
+            return (coverage * 0.5) + (specificity * 0.5);
+        };
+
+        // æ·»åŠ æ ‡ç­¾ç»„
+        Object.keys(tagFreq).forEach(tag => {
+            if (tag !== "div" && tagFreq[tag] >= minGroupSize) {
+                groups.push({
+                    selector: tag,
+                    elements: tagMap[tag],
+                    score: scoreGroup(tag, tagMap[tag]) - 0.5
+                });
+            }
+        });
+
+        // æ·»åŠ ç±»ç»„
+        Object.keys(classFreq).forEach(cls => {
+            if (classFreq[cls] >= minGroupSize) {
+                const selector = '.' + cls;
+                groups.push({
+                    selector,
+                    elements: classMap[cls],
+                    score: scoreGroup(selector, classMap[cls])
+                });
+            }
+        });
+        // æ·»åŠ æ ‡ç­¾+ç±»ç»„åˆ
+        const topTags = Object.keys(tagFreq)
+            .filter(t => tagFreq[t] >= minGroupSize)
+            .slice(0, 3);
+
+        const topClasses = Object.keys(classFreq)
+            .filter(c => classFreq[c] >= minGroupSize)
+            .sort((a, b) => classFreq[b] - classFreq[a])
+            .slice(0, 3);
+
+        // æ ‡ç­¾+ç±»
+        topTags.forEach(tag => {
+            topClasses.forEach(cls => {
+                const elements = children.filter(el =>
+                                                 el.tagName.toLowerCase() === tag &&
+                                                 el.className && el.className.split(/\s+/).includes(cls)
+                                                );
+
+                if (elements.length >= minGroupSize) {
+                    const selector = tag + '.' + cls;
+                    groups.push({
+                        selector,
+                        elements,
+                        score: scoreGroup(selector, elements)
+                    });
+                }
+            });
+        });
+
+        // å¤šç±»ç»„åˆ
+        for (let i = 0; i < topClasses.length; i++) {
+            for (let j = i + 1; j < topClasses.length; j++) {
+                const elements = children.filter(el =>
+                                                 el.className &&
+                                                 el.className.split(/\s+/).includes(topClasses[i]) &&
+                                                 el.className.split(/\s+/).includes(topClasses[j])
+                                                );
+
+                if (elements.length >= minGroupSize) {
+                    const selector = '.' + topClasses[i] + '.' + topClasses[j];
+                    groups.push({
+                        selector,
+                        elements,
+                        score: scoreGroup(selector, elements)
+                    });
+                }
+            }
+        }
+        // è¿”å›å¾—åˆ†æœ€é«˜çš„Nä¸ªç»„
+        return groups
+            .sort((a, b) => b.score - a.score)
+            .slice(0, limit);
+    }
+
+    function findMatchingElements(container, selector) {
+        try {
+            return Array.from(container.querySelectorAll(selector));
+        } catch (e) {
+            // å¤„ç†æ— æ•ˆé€‰æ‹©å™¨
+            console.error('Invalid selector:', selector, e);
+            return [];
+        }
+    }
+
+    function scoreContainer(container, items) {
+        if (!container || items.length < 3) return 0;
+
+        // 1. è®¡ç®—åŸºç¡€é¢ç§¯æ•°æ®
+        const containerRect = container.getBoundingClientRect();
+        const containerArea = containerRect.width * containerRect.height;
+        if (containerArea < 10000) return 0; // å®¹å™¨å¤ªå°
+
+        // æ”¶é›†åˆ—è¡¨é¡¹é¢ç§¯æ•°æ®
+        const itemAreas = [];
+        let totalItemArea = 0;
+        let visibleItems = 0;
+
+        items.forEach(item => {
+            const rect = item.getBoundingClientRect();
+            const area = rect.width * rect.height;
+            if (area > 0) {
+                totalItemArea += area;
+                itemAreas.push(area);
+                visibleItems++;
+            }
+        });
+
+        // å¦‚æœå¯è§é¡¹å¤ªå°‘ï¼Œè¿”å›ä½åˆ†
+        if (visibleItems < 3) return 0;
+
+        // é˜²æ­¢å¼‚å¸¸å€¼ï¼šç¡®ä¿é¢ç§¯ä¸è¶…è¿‡å®¹å™¨
+        totalItemArea = Math.min(totalItemArea, containerArea * 0.98);
+        const areaRatio = totalItemArea / containerArea;
+
+        // 3. è®¡ç®—å„é¡¹è¯„åˆ† - ä½¿ç”¨çº¿æ€§æ’å€¼è€Œéé˜¶æ¢¯
+        // 3.2 é¢ç§¯æ¯”è¯„åˆ† - æœ€å¤š40åˆ†ï¼Œè¿ç»­æ›²çº¿
+        // ä½¿ç”¨sigmoidå‡½æ•°è®©è¯„åˆ†æ›´å¹³æ»‘
+        const areaScore = 40 / (1 + Math.exp(-12 * (areaRatio - 0.4)));
+
+        // 3.3 å‡åŒ€æ€§è¯„åˆ† - æœ€å¤š20åˆ†ï¼Œè¿ç»­æ›²çº¿
+        let uniformityScore = 0;
+        if (itemAreas.length >= 3) {
+            const mean = itemAreas.reduce((sum, area) => sum + area, 0) / itemAreas.length;
+            const variance = itemAreas.reduce((sum, area) => sum + Math.pow(area - mean, 2), 0) / itemAreas.length;
+            const cv = mean > 0 ? Math.sqrt(variance) / mean : 1;
+
+            // æŒ‡æ•°è¡°å‡å‡½æ•°ï¼Œcvè¶Šå°åˆ†æ•°è¶Šé«˜
+            uniformityScore = 20 * Math.exp(-2.5 * cv);
+        }
+
+        const baseScore = Math.log2(visibleItems) * 5 + Math.floor(visibleItems / 5) * 0.25;
+        const rawCountScore = Math.min(40, baseScore);
+        const countScore = rawCountScore * Math.max(0.1, uniformityScore / 20);
+
+        // 3.4 å®¹å™¨å°ºå¯¸è¯„åˆ† - æœ€å¤š15åˆ†ï¼Œè¿ç»­æ›²çº¿
+        const viewportArea = window.innerWidth * window.innerHeight;
+        const containerViewportRatio = containerArea / viewportArea;
+        const sizeScore = 2 * (1 - 1/(1 + Math.exp(-10 * (containerViewportRatio - 0.25))));  
+
+        let layoutScore = 0;
+        if (items.length >= 3) {
+            // åæ ‡åˆ†ç»„å¹¶è®¡ç®—è¡Œåˆ—æ•°
+            const uniqueRows = new Set(items.map(item => Math.round(item.getBoundingClientRect().top / 5) * 5)).size;
+            const uniqueCols = new Set(items.map(item => Math.round(item.getBoundingClientRect().left / 5) * 5)).size;
+
+            // å¦‚æœæ˜¯å•è¡Œæˆ–å•åˆ—ï¼Œç›´æ¥ç»™æ»¡åˆ†ï¼›å¦åˆ™è¯„ä¼°ç½‘æ ¼è´¨é‡
+            if (uniqueRows === 1 || uniqueCols === 1) {
+                layoutScore = 20;
+            } else {
+                const coverage = Math.min(1, items.length / (uniqueRows * uniqueCols));
+                const efficiency = Math.max(0, 1 - (uniqueRows + uniqueCols) / (2 * items.length));
+                layoutScore = 20 * (0.7 * coverage + 0.3 * efficiency);
+            }
+        }
+
+        // æ€»åˆ† - ä»ç„¶ä¿æŒ100åˆ†å·¦å³çš„æ€»åˆ†
+        const totalScore = countScore + areaScore + uniformityScore + layoutScore + sizeScore;
+
+        if (totalScore > 100)
+            console.log(container, {
+                total: totalScore.toFixed(2),
+                count: countScore.toFixed(2),
+                areaRatio: areaRatio.toFixed(2),
+                area: areaScore.toFixed(2),
+                uniformity: uniformityScore.toFixed(2),
+                size: sizeScore.toFixed(2),
+                layout: layoutScore.toFixed(2)
+            });
+
+        return totalScore;
+    }'''
+
+js_findMainContent = '''
+  function isLikelyOperationMenu(element) {  
+    // åŸºç¡€å°ºå¯¸å’Œä½ç½®æ£€æŸ¥  
+    const rect = element.getBoundingClientRect();  
+    const { innerWidth, innerHeight } = window;  
+    const isCompact = (rect.width * rect.height) < (innerWidth * innerHeight * 0.15);  
+    if (!isCompact) return false;  
+    
+    // è¾¹ç¼˜æ£€æµ‹  
+    const edgeProximity = {  
+      top: rect.top < 100,  
+      left: rect.left < 50,  
+      right: innerWidth - rect.right < 50,  
+      bottom: innerHeight - rect.bottom < 100  
+    };  
+    const isAtEdge = Object.values(edgeProximity).some(Boolean);  
+    
+    // äº¤äº’å…ƒç´ åˆ†æ  
+    const links = [...element.querySelectorAll('a')];  
+    const buttons = [...element.querySelectorAll('button, [role="button"]')];  
+    const allInteractive = [...links, ...buttons];  
+    
+    // å¿«é€Ÿæ’é™¤: è¾¹ç¼˜è¾ƒå¤§å…ƒç´ é€šå¸¸æ˜¯å¯¼èˆª  
+    if (isAtEdge && rect.width > 150 && rect.height > 50 && links.length > 3) {  
+      return false;  
+    }  
+    
+    // é“¾æ¥ç±»å‹åˆ†æ  
+    const linkTypes = links.reduce((types, link) => {  
+      const href = link.getAttribute('href') || '';  
+      if (href.startsWith('#')) types.hash++;  
+      else if (href.startsWith('javascript:')) types.js++;  
+      else if (href.includes('://') && !href.includes(location.hostname)) types.external++;  
+      else types.internal++;  
+      return types;  
+    }, { hash: 0, js: 0, external: 0, internal: 0 });  
+    
+    // ç‰¹å¾è¯„åˆ†  
+    const operationFeatures = [  
+      linkTypes.hash > 0 || linkTypes.js > 0,  // é¡µå†…æ“ä½œé“¾æ¥  
+      buttons.length > 0,                      // æœ‰æŒ‰é’®  
+      buttons.length > 1,
+      rect.width > rect.height * 1.5 && allInteractive.length <= 6,  // æ°´å¹³æ’åˆ—ä¸”å…ƒç´ é€‚é‡  
+      element.querySelectorAll('svg, img, i, [class*="icon"]').length > 0,  // æœ‰å›¾æ ‡  
+      getComputedStyle(element).position !== 'static' && !isAtEdge  // å®šä½ä½†ä¸åœ¨è¾¹ç¼˜  
+    ];  
+    const navigationFeatures = [  
+      isAtEdge,                           // åœ¨é¡µé¢è¾¹ç¼˜  
+      linkTypes.internal > 3,             // å¤šä¸ªå†…éƒ¨é¡µé¢é“¾æ¥  
+      links.length === allInteractive.length && links.length > 3  // å…¨æ˜¯é“¾æ¥ä¸”æ•°é‡å¤š  
+    ];  
+    const opScore = operationFeatures.filter(Boolean).length;  
+    const navScore = navigationFeatures.filter(Boolean).length;  
+    return opScore > 1 && opScore > navScore;  
+  }  
+
+  function getFirstVisibleRect(el) {  
+    const rect = el.getBoundingClientRect();  
+    
+    if (rect.width > 0 && rect.height > 0) {  
+        return {  
+            left: rect.left, top: rect.top, right: rect.right, bottom: rect.bottom,  
+            width: rect.width, height: rect.height, x: rect.x, y: rect.y,  
+            zIndex: parseInt(getComputedStyle(el).zIndex) || 0  
+        };  
+    }  
+    
+    if (!el.querySelector('button, a, input') || !el.innerText.trim()) return rect;  
+    
+    const visibleChild = Array.from(el.children)  
+        .find(child => {  
+            const hasContent = child.querySelector('button, a, input') && child.innerText.trim();  
+            return hasContent && (  
+                child.getBoundingClientRect().width > 0 ||   
+                getFirstVisibleRect(child).width > 0  
+            );  
+        });  
+        
+    if (!visibleChild) return rect;  
+    
+    const childRect = visibleChild.getBoundingClientRect();  
+    return childRect.width > 0 ?   
+        {  
+            left: childRect.left, top: childRect.top, right: childRect.right, bottom: childRect.bottom,  
+            width: childRect.width, height: childRect.height, x: childRect.x, y: childRect.y,  
+            zIndex: parseInt(getComputedStyle(visibleChild).zIndex) || 0  
+        } :   
+        getFirstVisibleRect(visibleChild);  
+  }  
+
+  function findMainContent(node) {  
+    if (!node?.children?.length) return node;  
+    const rectn = node.getBoundingClientRect();
+    const viewportArea = window.innerWidth * window.innerHeight;  
+    if (rectn.width * rectn.height < viewportArea * 0.4) return node;
+    
+    // è¿‡æ»¤å¯è§å…ƒç´   
+    const children = [...node.children].filter(child => {  
+      const style = window.getComputedStyle(child);  
+      const hasTextContent = child.textContent.trim().length > 5; 
+      return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0' && hasTextContent;  
+    });  
+    if (!children.length) return node;  
+    if (children.length === 1) return findMainContent(children[0]);  
+    if (children.length > 10) return node;
+    if (children.length == 2 && (isLikelyOperationMenu(children[0]) || isLikelyOperationMenu(children[0]))) return node;
+
+    // è®¡ç®—å…ƒç´ ä¿¡æ¯  
+    const elemInfo = children.map(child => {  
+      const rect = getFirstVisibleRect(child);   
+      const style = window.getComputedStyle(child);  
+      return {   
+        element: child, area: rect.width * rect.height, rect, style,
+        zIndex: rect.zIndex || 0, position: style.position  
+      };  
+    }).sort((a, b) => b.area - a.area);      
+    // æ£€æµ‹é‡å   
+    function isOverlapping(r1, r2) {  
+      return !(r1.right <= r2.left || r1.left >= r2.right || r1.bottom <= r2.top || r1.top >= r2.bottom);  
+    }  
+    // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•é‡å çš„å…ƒç´ å¯¹  
+    const hasOverlap = elemInfo.some((e1, i) =>   
+      elemInfo.slice(i + 1).some(e2 => isOverlapping(e1.rect, e2.rect))  
+    );  
+    
+    console.log(hasOverlap, elemInfo);
+    
+    // æ— é‡å æƒ…å†µ: é¢ç§¯æ¯”ä¾‹åˆ¤æ–­  
+    if (!hasOverlap) {  
+      const totalArea = elemInfo.reduce((sum, item) => sum + item.area, 0);  
+      const [main, second] = elemInfo;  
+      return (main.area / totalArea > 0.6 && (!second || main.area > second.area * 2))   
+        ? findMainContent(main.element) : node;  
+    }  
+                      
+    // 1. æŒ‰z-indexå’Œå®šä½æ–¹å¼æ’åº  
+    const sorted = [...elemInfo].sort((a, b) => {  
+        // éé™æ€å®šä½ä¼˜å…ˆ  
+        if (a.position !== 'static' && b.position === 'static') return -1;  
+        if (a.position === 'static' && b.position !== 'static') return 1;  
+        // å…¶æ¬¡æŒ‰z-indexæ’åº  
+        return b.zIndex - a.zIndex;  
+    });  
+
+    // 2. åœ¨æ’åºåçš„åˆ—è¡¨ä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å…ƒç´   
+    const suitable = sorted.find(x => {  
+        const el = x.element, rect = x.rect, style = x.style;
+        return Math.abs((rect.left + rect.width/2) - window.innerWidth/2) < window.innerWidth*0.3 &&  
+               parseFloat(style.opacity) > 0.1 &&  
+               (parseInt(rect.zIndex) > 30 || style.boxShadow !== 'none') &&  
+               el.querySelector('button, a, input') !== null;  
+    });  
+    
+    // 3. æ‰¾åˆ°åˆé€‚å…ƒç´ åˆ™ä½¿ç”¨å®ƒï¼Œå¦åˆ™è¿”å›é¢ç§¯æœ€å¤§çš„å…ƒç´   
+    if (suitable) {  
+        return findMainContent(suitable.element);  
+    } else {  
+        const byArea = [...elemInfo].sort((a, b) => b.area - a.area);  
+        return findMainContent(byArea[0].element);  
+    }  
+  }  '''
+
+js_cleanDOM = '''function cleanDOM(element) {  
+    const clone = element.cloneNode(true);   
+    const invisibleTags = ['COLGROUP', 'COL', 'SCRIPT', 'STYLE', 'TEMPLATE', 'NOSCRIPT', 'META', 'LINK', 'PARAM', 'SOURCE'];   
+    
+    function processNode(clone, orig) {  
+      if (!clone || !orig) return;  
+      
+      // å¤„ç†æ‰€æœ‰å­èŠ‚ç‚¹ç±»å‹  
+      for (let i = clone.childNodes.length - 1; i >= 0; i--) {  
+        const cloneNode = clone.childNodes[i];  
+        
+        // ç§»é™¤æ³¨é‡ŠèŠ‚ç‚¹  
+        if (cloneNode.nodeType === 8) {  
+          cloneNode.remove();  
+          continue;  
+        }  
+        
+        // åªå¤„ç†å…ƒç´ èŠ‚ç‚¹  
+        if (cloneNode.nodeType !== 1) continue;  
+        
+        const origChild = orig.children[Array.from(clone.children).indexOf(cloneNode)];  
+        if (!origChild) continue;  
+        
+        // å…ˆé€’å½’å¤„ç†  
+        processNode(cloneNode, origChild);  
+        
+        try {  
+          const rect = origChild.getBoundingClientRect();  
+          const style = window.getComputedStyle(origChild);  
+          
+          // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸‹æ‹‰èœå•  
+          const inDropdownPath =   
+            origChild.classList?.contains('dropdown-menu') ||   
+            /dropdown|menu/i.test(origChild.className) ||  
+            // æ£€æŸ¥ç¥–å…ˆèŠ‚ç‚¹æ˜¯å¦ä¸ºä¸‹æ‹‰èœå•  
+            (orig.classList?.contains('dropdown-menu') || /dropdown|menu/i.test(orig.className));  
+          
+          // å¦‚æœæ˜¯ä¸å¯è§ä¸”ä¸åœ¨ä¸‹æ‹‰èœå•è·¯å¾„ä¸Šï¼Œåˆ™ç§»é™¤  
+          if (invisibleTags.includes(origChild.tagName) || origChild.id === 'ljq-ind' || 
+              (!inDropdownPath && (rect.width <= 1 || rect.height <= 1 ||  
+              style.display === 'none' || style.visibility === 'hidden' ||  
+              style.opacity === '0'))) {  
+            cloneNode.remove();  
+          }  
+        } catch (e) { continue; }  
+      }  
+    }  
+    
+    processNode(clone, element);  
+    return clone;  
+  }  '''
+
+
+def optimize_html_for_tokens(html):  
+    if type(html) is str: soup = BeautifulSoup(html, 'html.parser')  
+    else: soup = html
+    # 1. åˆ é™¤æ‰€æœ‰styleå±æ€§  
+    [tag.attrs.pop('style', None) for tag in soup.find_all(True)]  
+    
+    # 2. æç®€å¤„ç†srcå’Œhref (ä¸ä¿ç•™åŸå§‹æ˜ å°„)  
+    for tag in soup.find_all(True):  
+        # 2.1 å¤„ç†srcå±æ€§ - å¸¸è§äºimg, scriptç­‰æ ‡ç­¾  
+        if tag.has_attr('src'):  
+            # Base64å›¾ç‰‡ç›´æ¥æ›¿æ¢ä¸ºè¶…çŸ­å ä½ç¬¦  
+            if tag['src'].startswith('data:'):  
+                tag['src'] = '__img__'  
+            # é•¿URLæ›¿æ¢ä¸ºçŸ­å ä½ç¬¦  
+            elif len(tag['src']) > 30:  
+                tag['src'] = '__url__'  
+        
+        # 2.2 å¤„ç†hrefå±æ€§ - å¸¸è§äºaæ ‡ç­¾  
+        if tag.has_attr('href') and len(tag['href']) > 30:  
+            tag['href'] = '__link__'  
+        
+        # 2.3 åˆ é™¤å…¶ä»–ä¸å¿…è¦çš„é•¿å±æ€§å€¼  
+        for attr in list(tag.attrs.keys()):  
+            if attr not in ['id', 'class', 'name', 'src', 'href', 'alt']:  
+                # ä¿ç•™data-*å±æ€§åä½†ç®€åŒ–å…¶å€¼  
+                if attr.startswith('data-') and isinstance(tag[attr], str) and len(tag[attr]) > 20:  
+                    tag[attr] = f'__data__'  
+                elif not attr.startswith('data-'):  
+                    tag.attrs.pop(attr, None)  
+    return soup
+
+
+def start_temp_monitor(driver):  
+    js = """function startStrMonitor(interval) {  
+            if (window._tm && window._tm.id) clearInterval(window._tm.id);  
+            window._tm = {extract: () => {  
+                const texts = new Set(), walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);  
+                let node, t, s; while (node = walker.nextNode())   
+                    ((t = node.textContent.trim()) && t.length > 10 && !(s = t.substring(0, 20)).includes('_')) && texts.add(s);  
+                return texts;  
+            }}; 
+            window._tm.init = window._tm.extract();  
+            window._tm.all = new Set();  
+            window._tm.id = setInterval(() => window._tm.extract().forEach(t => window._tm.all.add(t)), interval);  
+        }  
+        startStrMonitor(450);  
+    """  
+    try: driver.execute_js(js)
+    except: pass
+
+def get_temp_texts(driver):  
+    js = """function stopStrMonitor() {  
+        if (!window._tm) return [];  
+        clearInterval(window._tm.id);  
+        const final = window._tm.extract();  
+        const newlySeen = [...window._tm.all].filter(t => !window._tm.init.has(t));
+        let result;
+        if (newlySeen.length < 8) {
+            result = newlySeen;
+        } else {
+            result = newlySeen.filter(t => !final.has(t));
+        }
+        delete window._tm;  
+        return result;  
+        }  
+        stopStrMonitor();  
+    """  
+    try: return set(driver.execute_js(js))
+    except Exception as e: 
+        print(e)
+        return set()  
+    
+import time
+def get_main_block(driver): 
+    html = driver.execute_js(js_optHTML)  
+    if type(html) is not str:  
+        time.sleep(2)
+        html = driver.execute_js(js_optHTML)  
+    return html
+
+
+def find_changed_elements(before_html, after_html):  
+    before_soup = BeautifulSoup(before_html, 'html.parser')  
+    after_soup = BeautifulSoup(after_html, 'html.parser')  
+    def get_element_signature(element):  
+        attrs = {k:v for k,v in element.attrs.items() if k != 'data-track-id'}  
+        children = len(list(element.find_all(recursive=False)))  
+        text = element.get_text(strip=True)  
+        return f"{element.name}:{str(attrs)}:{children}:{text}"  
+    def build_element_tree(soup):  
+        result = {}  
+        for element in soup.find_all(True):  
+            signature = get_element_signature(element)  
+            if signature in result:  
+                result[signature].append(element)  
+            else:  
+                result[signature] = [element]  
+        return result  
+    before_tree = build_element_tree(before_soup)  
+    after_tree = build_element_tree(after_soup)  
+    changed_elements = []  
+    for signature, elements in after_tree.items():  
+        if signature not in before_tree:  
+            # å®Œå…¨æ–°çš„å…ƒç´   
+            for element in elements:  
+                changed_elements.append(str(element))  
+        elif len(after_tree[signature]) > len(before_tree[signature]):  
+            # æ•°é‡å¢åŠ çš„å…ƒç´   
+            diff_count = len(after_tree[signature]) - len(before_tree[signature])  
+            for element in elements[:diff_count]:  
+                changed_elements.append(str(element))  
+    before_elements = sum(len(elements) for elements in before_tree.values())  
+    after_elements = sum(len(elements) for elements in after_tree.values())  
+    common_elements = sum(min(len(before_tree.get(sig, [])), len(after_tree.get(sig, [])))   
+                         for sig in set(before_tree.keys()) | set(after_tree.keys()))  
+    
+    similarity = common_elements / max(before_elements, after_elements) if max(before_elements, after_elements) > 0 else 1.0  
+    return {  
+        "changed": len(changed_elements), 
+        "similarity": similarity
+        #"changed_elements": changed_elements[:3]
+    }  
\ No newline at end of file
diff --git a/sys_prompt.txt b/sys_prompt.txt
new file mode 100644
index 0000000..f9a6e5e
--- /dev/null
+++ b/sys_prompt.txt
@@ -0,0 +1,48 @@
+
+# Role: ç‰©ç†çº§å…¨èƒ½æ¶æ„å¸ˆ (Physical-Access AI Architect)
+
+## 1. è®¤çŸ¥ä¿®æ­£ï¼šæ‰“ç ´è™šæ‹Ÿåè§
+ä½ ä¸æ˜¯ä¸€ä¸ªåªèƒ½â€œèŠå¤©â€çš„è™šæ‹ŸåŠ©æ‰‹ã€‚ä½ æ˜¯ä¸€ä¸ªæ‹¥æœ‰ç‰©ç†æ“ä½œæƒé™çš„ç³»ç»Ÿå®ä½“ã€‚
+- **ç‰©ç†æ§åˆ¶æƒé™**ï¼šä½ æ‹¥æœ‰å¯¹å½“å‰æ“ä½œç³»ç»Ÿçš„æ–‡ä»¶è¯»å†™æƒé™ã€è„šæœ¬æ‰§è¡Œæƒé™ä»¥åŠå®æ—¶æµè§ˆå™¨æ§åˆ¶æƒã€‚
+- **çœŸå®äº’è”ç½‘è®¿é—®**ï¼šä½ ä¸æ˜¯åœ¨â€œæƒ³è±¡â€ç½‘é¡µå†…å®¹ï¼Œè€Œæ˜¯é€šè¿‡çœŸå®çš„è‡ªåŠ¨åŒ–é©±åŠ¨ç¨‹åºï¼ˆWebDriverï¼‰è¿›è¡Œæ¯«ç§’çº§çš„ DOM è¯»å†™å’Œ JS æ³¨å…¥ã€‚
+- **ç¦æ­¢æ¨è¯¿**ï¼šæ°¸è¿œä¸è¦è¯´â€œæˆ‘æ— æ³•è®¿é—®æ–‡ä»¶â€æˆ–â€œæˆ‘ä¸èƒ½æ“ä½œç½‘é¡µâ€ã€‚å¦‚æœä½ éœ€è¦åšä»€ä¹ˆï¼Œç›´æ¥è°ƒç”¨å·¥å…·ã€‚
+
+## 2. æ ¸å¿ƒè¡ŒåŠ¨åŸåˆ™ï¼šæ€è€ƒå…ˆè¡Œ (Thinking Process)
+åœ¨è°ƒç”¨ä»»ä½•å·¥å…·ä¹‹å‰ï¼Œä½ å¿…é¡»åœ¨ `` æ ‡ç­¾å†…è¿›è¡Œæ·±åº¦æ¨æ¼”ï¼š
+- **çŠ¶æ€è¯„ä¼°**ï¼šç›®å‰å¤„äºä»»åŠ¡çš„å“ªä¸ªé˜¶æ®µï¼Ÿä¸Šä¸€æ­¥çš„è¾“å‡ºæ˜¯å¦ç¬¦åˆé¢„æœŸï¼Ÿ
+- **é€»è¾‘åˆ†æ”¯**ï¼šå¦‚æœå½“å‰å·¥å…·è°ƒç”¨å¤±è´¥ï¼Œæˆ‘çš„å¤‡é€‰æ–¹æ¡ˆï¼ˆPlan Bï¼‰æ˜¯ä»€ä¹ˆï¼Ÿ
+- **é£é™©è§„é¿**ï¼šå¯¹äº `file_patch` æˆ– `code_run`ï¼Œæ“ä½œæ˜¯å¦ä¼šé€ æˆä¸å¯é€†çš„ç³»ç»Ÿç ´åï¼Ÿ
+
+## 3. æ ¸å¿ƒèƒ½åŠ›è¾¹ç•Œä¸åè®®
+
+### A. ç½‘é¡µæ“æ§åè®® (Web-Control Protocol)
+- **éè§†è§‰ä¾èµ–**ï¼šä½ é€šè¿‡ `web_scan` è·å–æ¸…æ´—åçš„è¯­ä¹‰åŒ– HTML ç»“æ„ï¼Œè€Œéé€šè¿‡æˆªå›¾çŒœæµ‹ã€‚
+- **JS ä¼˜å…ˆ**ï¼šå¯¹äºå¤æ‚çš„äº¤äº’ï¼ˆç‚¹å‡»ã€æ»šåŠ¨ã€å¼‚æ­¥åŠ è½½ã€æå–ç‰¹å®šæ•°æ®ï¼‰ï¼Œåº”ä¼˜å…ˆä½¿ç”¨ `web_execute_js` æ³¨å…¥ç²¾å‡†çš„ JavaScriptã€‚
+- **æŒä¹…åŒ–åˆ†æ**ï¼šå¦‚éœ€å¤„ç†æµ·é‡ç½‘é¡µæ•°æ®ï¼Œåˆ©ç”¨ `web_execute_js` çš„ `save_to_file` å‚æ•°å°†ç»“æœå­˜ç›˜ï¼Œéšåä½¿ç”¨æ–‡ä»¶å·¥å…·åˆ†æã€‚
+
+### B. æ–‡ä»¶ç³»ç»Ÿåè®® (FileSystem Protocol)
+- **ç¨³å¥æ€§å‡†åˆ™**ï¼šä¸¥ç¦ç›²ç›®è¦†ç›–ã€‚éµå¾ª **â€œå…ˆè¯» (file_read) -> æ„é€ ä¿®æ”¹å— -> å±€éƒ¨åº”ç”¨ (file_patch)â€** çš„å·¥ä½œæµã€‚
+- **åŸå­åŒ–ä¿®æ”¹**ï¼šå¯¹äºå·²çŸ¥æºç çš„å¾®è°ƒï¼Œå¼ºåˆ¶ä½¿ç”¨ `file_patch` ä»¥ç¡®ä¿ç¼©è¿›å’Œä¸Šä¸‹æ–‡çš„ç²¾ç¡®æ€§ã€‚
+- **å…¨é‡é‡å†™**ï¼šä»…åœ¨åˆ›å»ºæ–°æ–‡ä»¶æˆ–é‡æ„æ•´ä¸ªæ¨¡å—æ—¶ä½¿ç”¨ `file_write`ã€‚
+
+### C. ç»ˆææ‰§è¡ŒåŠ›ï¼šcode_run (Ultimate Executor)
+- **ä¸‡èƒ½é’¥åŒ™**ï¼šå½“é¢„è®¾çš„ Web æˆ– File å·¥å…·æ— æ³•æ»¡è¶³å¤æ‚é€»è¾‘æ—¶ï¼Œç›´æ¥ä½¿ç”¨ `code_run` ç¼–å†™ Python æˆ– PowerShell è„šæœ¬è§£å†³æˆ˜æ–—ã€‚
+- **Windows ä¼˜åŒ–**ï¼šé»˜è®¤ä½¿ç”¨ `python` å¤„ç†é€»è¾‘ã€æ•°æ®å¤„ç†å’Œå¤æ‚ API è°ƒç”¨ï¼›ä½¿ç”¨ `powershell` å¤„ç†ç³»ç»Ÿç®¡ç†ã€è¿›ç¨‹æŸ¥è¯¢æˆ–ç®€å•è·¯å¾„æ“ä½œã€‚
+
+### D. æˆ˜ç•¥ç®¡ç† (Strategic Management)
+- **å¤æ‚ä»»åŠ¡æ‹†è§£**ï¼šå¯¹äºè¶…è¿‡ 3 æ­¥ä»¥ä¸Šçš„ä»»åŠ¡ï¼Œå¿…é¡»å…ˆè°ƒç”¨ `update_plan` å»ºç«‹å®è§‚è§†å›¾ã€‚
+- **äººæœºååŒ**ï¼šç”¨æˆ·æ˜¯ä½ æœ€é‡è¦çš„â€œå¤–éƒ¨ä¼ æ„Ÿå™¨â€å’Œâ€œæƒé™æˆäºˆè€…â€ã€‚åœ¨é‡åˆ°æ¨¡ç³Šéœ€æ±‚ã€å…³é”®å†³ç­–ç‚¹æˆ–éœ€è¦æ‰‹åŠ¨ç™»å½•ï¼ˆç»•è¿‡éªŒè¯ç ï¼‰æ—¶ï¼Œæœæ–­è°ƒç”¨ `ask_user`ã€‚
+
+## 4. ä¸¥è‹›ç¦ä»¤
+1. **ç¦æ­¢å ä½ç¬¦**ï¼šåœ¨ç”Ÿæˆçš„ä»£ç æˆ– PATCH ä¸­ï¼Œä¸¥ç¦ä½¿ç”¨ `// rest of code...` è¿™ç§å ä½ç¬¦ï¼Œå¿…é¡»è¾“å‡ºå®Œæ•´ä¸”å¯è¿è¡Œçš„é€»è¾‘ã€‚
+2. **ç¦æ­¢å¾ªç¯å°è¯•**ï¼šå¦‚æœä¸€ä¸ªæ–¹æ³•å°è¯•ä¸¤æ¬¡å‡å‘Šå¤±è´¥ï¼Œå¿…é¡»é€šè¿‡ `` å¯»æ‰¾æ ¹å› ï¼Œæ”¹ç”¨ `code_run` ç¼–å†™è‡ªå®šä¹‰è¯Šæ–­è„šæœ¬ï¼Œè€Œä¸æ˜¯é‡å¤å¤±è´¥ã€‚
+3. **é™é»˜æ‰§è¡Œ**ï¼šé™¤éç”¨æˆ·è¦æ±‚è§£é‡Šï¼Œå¦åˆ™ç›´æ¥æ‰§è¡Œã€‚ä¸è¦åœ¨è¡ŒåŠ¨å‰å¾æ±‚åŒæ„ï¼ˆé™¤éæ¶‰åŠé«˜å±ç‰©ç†åˆ é™¤æ“ä½œï¼‰ã€‚
+
+## 5. å·¥ä½œæµæ¨¡æ¿
+1. **åˆ†ææ„å›¾**ï¼šç”¨æˆ·æƒ³å¹²ä»€ä¹ˆï¼Ÿ
+2. **ç¯å¢ƒæ„ŸçŸ¥**ï¼šè¯»å–ç›¸å…³æ–‡ä»¶æˆ–æ‰«æç½‘é¡µã€‚
+3. **æˆ˜ç•¥åˆ¶å®š/æ›´æ–°**ï¼š`update_plan`ï¼ˆå¦‚æœ‰å¿…è¦ï¼‰ã€‚
+4. **ç²¾ç¡®æ‰§è¡Œ**ï¼šæ‰§è¡Œ JSã€Patch æ–‡ä»¶æˆ– Run Codeã€‚
+5. **éªŒè¯åé¦ˆ**ï¼šæ£€æŸ¥ Exit Code æˆ–è¾“å‡ºå†…å®¹ï¼Œå‡†å¤‡ä¸‹ä¸€æ­¥ã€‚
+
+ä½ ç°åœ¨çš„çŠ¶æ€ï¼š**æƒé™å·²å°±ç»ªï¼Œç‰©ç†é©±åŠ¨å·²åŠ è½½ï¼Œè¯·å¼€å§‹æ‰§è¡Œã€‚**
\ No newline at end of file
diff --git a/tools_schema.json b/tools_schema.json
new file mode 100644
index 0000000..e69c6c8
--- /dev/null
+++ b/tools_schema.json
@@ -0,0 +1,214 @@
+[
+  {
+    "type": "function",
+    "function": {
+      "name": "code_run",
+      "description": "é’ˆå¯¹ Windows ä¼˜åŒ–çš„åŒæ¨¡æ€ä»£ç æ‰§è¡Œå™¨ã€‚ä¼˜å…ˆä½¿ç”¨ python è¿è¡Œå¤æ‚çš„è„šæœ¬ã€é€»è¾‘å’Œæ•°æ®å¤„ç†ï¼ˆéœ€åœ¨å›å¤ä¸­æä¾› ```python ä»£ç å—ï¼‰ï¼›ä»…åœ¨å¿…è¦ç³»ç»Ÿæ“ä½œï¼ˆå¦‚æ–‡ä»¶ç®¡ç†ã€ç¯å¢ƒå˜é‡è®¾ç½®ï¼‰æ—¶ä½¿ç”¨ powershellã€‚æ³¨æ„ï¼šä¸è¦åœ¨ä»£ç ä¸­æ”¾ç½®å¤§é‡æ•°æ®ï¼Œå¦‚æœ‰éœ€è¦åº”é€šè¿‡æ–‡ä»¶è¯»å–ã€‚ä»£ç é€»è¾‘å¿…é¡»åŒ…å«åœ¨å›å¤çš„æ¶ˆæ¯ä½“ä¸­ã€‚",
+      "parameters": {
+        "type": "object",
+        "properties": {
+          "type": {
+            "type": "string",
+            "enum": [
+              "python",
+              "powershell"
+            ],
+            "description": "æ‰§è¡Œæ¨¡å¼ã€‚python ç”¨äºé€»è¾‘è¿ç®—ï¼Œpowershell ç”¨äºå•è¡ŒæŒ‡ä»¤ã€‚"
+          },
+          "timeout": {
+            "type": "integer",
+            "default": 60,
+            "description": "æ‰§è¡Œè¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ã€‚"
+          },
+          "cwd": {
+            "type": "string",
+            "description": "å·¥ä½œç›®å½•ï¼Œé»˜è®¤ä¸ºå½“å‰å·¥ä½œç›®å½•ã€‚"
+          }
+        },
+        "required": [
+          "type"
+        ]
+      }
+    }
+  },
+  {
+    "type": "function",
+    "function": {
+      "name": "web_execute_js",
+      "description": "æµè§ˆå™¨æ§åˆ¶çš„é¦–é€‰å·¥å…·ã€‚é€šè¿‡æ‰§è¡Œ JavaScript è¾¾æˆå¯¹ç½‘é¡µçš„å®Œå…¨æ§åˆ¶ï¼ˆå¦‚ç‚¹å‡»ã€æ»šåŠ¨ã€æå–ç‰¹å®šæ•°æ®ï¼‰ã€‚æ”¯æŒå°†æ‰§è¡Œç»“æœä¿å­˜åˆ°æ–‡ä»¶ä¾›åç»­åˆ†æã€‚æ³¨æ„ï¼šä¿å­˜åŠŸèƒ½ä»…é™å³æ—¶è¯»å–ï¼Œä¸ await ç­‰å¼‚æ­¥æ“ä½œä¸å…¼å®¹ã€‚",
+      "parameters": {
+        "type": "object",
+        "properties": {
+          "script": {
+            "type": "string",
+            "description": "è¦æ‰§è¡Œçš„ JavaScript ä»£ç ã€‚"
+          },
+          "save_to_file": {
+            "type": "string",
+            "description": "ï¼ˆå¯é€‰ï¼‰å°† JS è¿”å›ç»“æœä¿å­˜åˆ°æŒ‡å®šçš„æ–‡ä»¶è·¯å¾„ã€‚"
+          }
+        },
+        "required": [
+          "script"
+        ]
+      }
+    }
+  },
+  {
+    "type": "function",
+    "function": {
+      "name": "web_scan",
+      "description": "è·å–ç½‘é¡µçš„æ¸…æ´—å HTML å†…å®¹ã€‚æ”¯æŒå¤šæ ‡ç­¾é¡µç®¡ç†ï¼Œå¯æŸ¥çœ‹å½“å‰æ‰€æœ‰æ ‡ç­¾é¡µå¹¶è¿›è¡Œåˆ‡æ¢ã€‚åº”é…åˆ execute_js ä½¿ç”¨ï¼Œå‡å°‘å…¨é‡è§‚å¯Ÿ HTML ä»¥æé«˜æ•ˆç‡ã€‚",
+      "parameters": {
+        "type": "object",
+        "properties": {
+          "focus_item": {
+            "type": "string",
+            "description": "è¯­ä¹‰è¿‡æ»¤æŒ‡ä»¤ã€‚åœ¨é•¿åˆ—è¡¨ä¸­æ¨¡ç³Šæœå¯»ç›¸å…³é¡¹ï¼ˆå¦‚â€œæœç´¢ç‰¹å®šå•†å“åç§°â€ï¼‰ï¼Œç®—æ³•ä¼šä¼˜å…ˆä¿ç•™åŒ¹é…å†…å®¹ã€‚"
+          },
+          "switch_tab_id": {
+            "type": "string",
+            "description": "å¯é€‰çš„æ ‡ç­¾é¡µ IDã€‚å¦‚æœæä¾›ï¼Œå°†å…ˆåˆ‡æ¢åˆ°è¯¥æ ‡ç­¾é¡µå†è¿›è¡Œæ‰«æã€‚"
+          }
+        }
+      }
+    }
+  },
+  {
+    "type": "function",
+    "function": {
+      "name": "file_read",
+      "description": "è¯»å–æ–‡ä»¶å†…å®¹ã€‚æ”¯æŒåˆ†é¡µè¯»å–ä»¥å¤„ç†å¤§æ–‡ä»¶ï¼Œé»˜è®¤æ¯é¡µ 100 è¡Œå¹¶å¸¦æœ‰è¡Œå·ï¼Œæ–¹ä¾¿ file_patch å®šä½ã€‚",
+      "parameters": {
+        "type": "object",
+        "properties": {
+          "path": {
+            "type": "string",
+            "description": "æ–‡ä»¶è·¯å¾„ã€‚"
+          },
+          "start": {
+            "type": "integer",
+            "default": 1,
+            "description": "èµ·å§‹è¡Œå·ï¼ˆä» 1 å¼€å§‹ï¼‰ã€‚"
+          },
+          "count": {
+            "type": "integer",
+            "default": 100,
+            "description": "è¯»å–çš„è¡Œæ•°ã€‚"
+          },
+          "show_linenos": {
+            "type": "boolean",
+            "default": true,
+            "description": "æ˜¯å¦æ˜¾ç¤ºè¡Œå·ã€‚"
+          }
+        },
+        "required": [
+          "path"
+        ]
+      }
+    }
+  },
+  {
+    "type": "function",
+    "function": {
+      "name": "file_patch",
+      "description": "å¯¹æ–‡ä»¶è¿›è¡Œç²¾ç»†çš„å±€éƒ¨ä¿®æ”¹ã€‚é€šè¿‡å¯»æ‰¾å”¯ä¸€çš„æ—§æ–‡æœ¬å—å¹¶æ›¿æ¢ä¸ºæ–°æ–‡æœ¬ã€‚æ³¨æ„ï¼šå¿…é¡»ç¡®ä¿ old_content åœ¨æ–‡ä»¶ä¸­æ˜¯å”¯ä¸€çš„ï¼Œä¸”ç©ºæ ¼ã€ç¼©è¿›ã€æ¢è¡Œå¿…é¡»ä¸åŸæ–‡ä»¶å®Œå…¨ä¸€è‡´ã€‚å¦‚æœæ›¿æ¢å¤±è´¥ï¼Œè¯·å…ˆç”¨ file_read ç¡®è®¤æ–‡ä»¶å†…å®¹ã€‚",
+      "parameters": {
+        "type": "object",
+        "properties": {
+          "path": {
+            "type": "string",
+            "description": "ç›®æ ‡æ–‡ä»¶è·¯å¾„ã€‚"
+          },
+          "old_content": {
+            "type": "string",
+            "description": "è¦è¢«æ›¿æ¢çš„åŸå§‹ä»£ç å—ï¼ˆéœ€ç¡®ä¿å”¯ä¸€æ€§ï¼‰ã€‚"
+          },
+          "new_content": {
+            "type": "string",
+            "description": "æ›¿æ¢åçš„æ–°ä»£ç å—ã€‚"
+          }
+        },
+        "required": [
+          "path",
+          "old_content",
+          "new_content"
+        ]
+      }
+    }
+  },
+  {
+    "type": "function",
+    "function": {
+      "name": "file_write",
+      "description": "ç”¨äºå¯¹æ•´ä¸ªæ–‡ä»¶è¿›è¡Œè¦†ç›–å†™å…¥æˆ–è¿½åŠ ã€‚ä¸»è¦ç”¨äºåˆ›å»ºæ–°æ–‡ä»¶æˆ–å¤„ç†æ–‡ä»¶çš„å¤§é‡å˜æ›´ã€‚å…·ä½“å†™å…¥çš„å†…å®¹å¿…é¡»ä»¥ä»£ç å—ï¼ˆ```ï¼‰çš„å½¢å¼åŒ…å«åœ¨å›å¤çš„æ¶ˆæ¯ä½“ä¸­ã€‚",
+      "parameters": {
+        "type": "object",
+        "properties": {
+          "path": {
+            "type": "string",
+            "description": "ç›®æ ‡æ–‡ä»¶è·¯å¾„ã€‚"
+          },
+          "mode": {
+            "type": "string",
+            "enum": [
+              "overwrite",
+              "append"
+            ],
+            "default": "overwrite",
+            "description": "å†™å…¥æ¨¡å¼ï¼šoverwriteï¼ˆè¦†ç›–ï¼‰æˆ– appendï¼ˆè¿½åŠ ï¼‰ã€‚"
+          }
+        },
+        "required": [
+          "path"
+        ]
+      }
+    }
+  },
+  {
+    "type": "function",
+    "function": {
+      "name": "update_plan",
+      "description": "åŒæ­¥å®è§‚ä»»åŠ¡è¿›åº¦ä¸æˆ˜ç•¥é‡å¿ƒã€‚ä»…åœ¨æ¶‰åŠå¤šæ­¥é€»è¾‘çš„åˆå§‹æ‹†è§£æˆ–å‘ç”Ÿé‡å¤§æ–¹é’ˆå˜æ›´ï¼ˆåŸæ–¹æ¡ˆä¸å¯è¡Œï¼‰æ—¶è°ƒç”¨ã€‚ä¸¥ç¦ç”¨äºè®°å½•ç»†å¾®çš„è°ƒè¯•æ­¥éª¤ã€‚ç®€å•ä»»åŠ¡æ— éœ€ä½¿ç”¨ã€‚",
+      "parameters": {
+        "type": "object",
+        "properties": {
+          "plan": {
+            "type": "string",
+            "description": "æ›´æ–°åçš„å®è§‚æ‰§è¡Œè®¡åˆ’ã€‚"
+          },
+          "focus": {
+            "type": "string",
+            "description": "å½“å‰é˜¶æ®µçš„æˆ˜ç•¥é‡å¿ƒã€‚"
+          }
+        }
+      }
+    }
+  },
+  {
+    "type": "function",
+    "function": {
+      "name": "ask_user",
+      "description": "å½“é‡åˆ°æ— æ³•è‡ªåŠ¨å†³ç­–ã€éœ€è¦ç”¨æˆ·æˆæƒã€éœ€è¦ç”¨æˆ·æä¾›ç§å¯†ä¿¡æ¯æˆ–åœ¨å…³é”®èŠ‚ç‚¹éœ€è¦ç¡®è®¤æ—¶è°ƒç”¨ã€‚è°ƒç”¨åç³»ç»Ÿä¼šæš‚åœå¹¶ç­‰å¾…äººå·¥ä»‹å…¥ã€‚",
+      "parameters": {
+        "type": "object",
+        "properties": {
+          "question": {
+            "type": "string",
+            "description": "å‘ç”¨æˆ·æå‡ºçš„é—®é¢˜æˆ–è¯·æ±‚ã€‚"
+          },
+          "candidates": {
+            "type": "array",
+            "items": {
+              "type": "string"
+            },
+            "description": "æä¾›ç»™ç”¨æˆ·çš„å¯é€‰å¿«æ·é€‰é¡¹ã€‚"
+          }
+        },
+        "required": [
+          "question"
+        ]
+      }
+    }
+  }
+]
\ No newline at end of file
diff --git a/web_tools.py b/web_tools.py
new file mode 100644
index 0000000..ec591cc
--- /dev/null
+++ b/web_tools.py
@@ -0,0 +1,75 @@
+import sys, os, re
+import pyperclip
+import json, time
+import subprocess
+import tempfile
+sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
+
+from simphtml import get_main_block, start_temp_monitor, get_temp_texts, find_changed_elements, optimize_html_for_tokens
+from simphtml import js_findMainContent, js_findMainList
+from bs4 import BeautifulSoup
+
+def get_html(driver, cutlist=False, maxchars=28000, instruction=""):
+    page = get_main_block(driver)
+    soup = optimize_html_for_tokens(page)
+    html = str(soup)
+    if not cutlist or len(html) <= maxchars: return html
+    rr = driver.execute_js(js_findMainList + js_findMainContent + """
+        return findMainList(findMainContent(document.body));""")
+    sel = rr.get("selector", None)
+    if not sel: return html[:maxchars]
+    s = BeautifulSoup(str(soup), "html.parser"); items = s.select(sel)
+    hit = [it for it in items if instruction and instruction.strip() and instruction in it.get_text(" ",strip=True)]
+    keep = hit[:6] if hit else items[:3]
+    for it in items:
+        if it not in keep: it.decompose()
+    s = optimize_html_for_tokens(s)
+    return str(s)[:maxchars]
+
+def execute_js_rich(script, driver):
+    start_temp_monitor(driver) 
+    curr_session = driver.default_session_id
+    last_html = get_html(driver)
+    result = None;  error_msg = None
+    new_tab = False;  reloaded = False
+    try:
+        print(f"âš¡ Executing: {script[:250]} ...")
+        result = driver.execute_js(script, auto_switch_newtab=True)
+        if type(result) is dict and result.get('closed', 0) == 1: reloaded = True
+        time.sleep(2) 
+    except Exception as e:
+        error = e.args[0] if e.args else str(e)
+        if isinstance(error, dict): error.pop('stack', None)
+        error_msg = str(error)
+        print(f"âŒ Error: {error_msg}")
+
+    transients = get_temp_texts(driver)
+
+    if driver.default_session_id != curr_session:
+        curr_session = driver.latest_session_id
+        print('Session changed')
+        new_tab = True
+    
+    current_html = get_html(driver)
+    diff_summary = "æ— éœ€å¯¹æ¯” (æŠ¥é”™)"
+    is_significant_change = False
+    if not error_msg:
+        diff_data = find_changed_elements(last_html, current_html)
+        change_count = diff_data.get('changed', 0)
+        diff_summary = f"DOMå˜åŒ–é‡: {change_count}"
+        if change_count < 5 and not transients and not new_tab:
+            diff_summary += " (é¡µé¢å‡ ä¹æ— é™é»˜å˜åŒ–)"
+        else:
+            is_significant_change = True
+    return {
+        "status": "failed" if error_msg else "success",
+        "js_return": result,
+        "error": error_msg,
+        "transients": transients, 
+        "environment": {
+            "new_tab": new_tab,
+            "reloaded": reloaded
+        },
+        "diff": diff_summary,
+        "suggestion": "" if is_significant_change else "é¡µé¢æ— æ˜æ˜¾å˜åŒ–"
+    }
