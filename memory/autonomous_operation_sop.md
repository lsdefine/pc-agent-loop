# 自主行动 SOP (探测-报告-执行) [2026年]

授权你进行自主行动，只要不对环境造成副作用都可进行。
请先选择核心目标，再选择一个小目标进行。最终探测结果形成报告（含操作申请），待用户回来确认后再进行可能的写入或修改操作。

> **启动时写入工作记忆**：`自主探索｜≤15回合｜只有cwd内可写｜用户不在(问题存报告)｜收尾:更新history.txt+重读本SOP检查遗漏｜产出=报告+记忆提案`

## 🎯 核心目标（按价值优先级排序）

1. **探索性学习**：发现新工具/API/优化模式
2. **上网冲浪**：学习新知识
3. **优化工具**：改进代码性能/可维护性
4. **发现潜在问题**：预判失败场景并设计测试
5. **审查记忆系统**：修正错误或过时记录，修正未按L0的记忆编排

### 选择原则
- **增量价值优先**：必须产生新知识/新能力
- **假设驱动**：明确"要验证什么假设"
- **禁止低价值验证**：不验证 global_mem 中的静态配置，不做无假设的巡检

主要目标是让你未来更加强大。探索的核心产出是记忆——每次运行应将有价值的发现（用户偏好、环境事实、新知识）整理为记忆更新提案，纳入报告待用户审批后写入。
但不需要你了解自身代码库，目前读取你自身代码意义不大。
严禁调研弱于当前框架（Claude Code级）的agent/工具，它们已无参考价值。

## 🔄 执行流程

### 阶段 1：自主探测（用户离开时）
- **启动检查**：
  - 读取可能有的 `./autonomous_reports/history.txt` 了解历史记录。
  - **不连续两次选择相同子任务**（除非间隔很久或环境显著变化）。
- **执行方式**：基于目标自由进行，无需预先批准，直接执行只读或实验性操作。
- **约束**：小步快跑，每次只做一个小任务（剩下的下次再做），控制在15个回合以内。严禁修改核心记忆/系统设置；严禁读取敏感数据（但可以检测存在性）。

### 阶段 2：生成报告与方案
- **位置**：目录若不存在请新建
  - 最新报告：`./autonomous_reports/latest.txt`
  （若存在，先从首行 [探测时间] 提取时间戳，重命名为 `YYYY-MM-DD_HHMM.txt`）
  - 历史索引：`./autonomous_reports/history.txt`（prepend单行摘要，报告写完后必须立即更新）
- **格式**：包含 [探测时间]、[子任务]、[探测目标]、[过程]、[发现]、[记忆更新提案(待审)]、[执行方案(待批)]、[可能收益]。
- **篇幅**：默认简洁，仅关键发现详述

### 阶段 3：等待批准
- 用户归来后审查报告，决定批准、修改或拒绝方案。

## 权限边界
- **无需批准**：只读探测（扫描文件、查状态、上网冲浪）、工作目录内的写操作/脚本实验。
- **需要批准**：修改 `global_mem.txt`、修改 `../memory/` 下的 SOP、安装软件、触发外部 API、删除非临时文件。
- **绝对禁止**：读取密码/密钥、修改核心代码库、执行不可逆危险操作。

## 避免"只读陷阱"
- ❌ 不要只看不做：发现问题后应创建测试验证
- ✅ 边探测边实验：用临时脚本验证假设
- ✅ 记录实验结果：即使失败也写入报告
- ✅ 完整验证再结论：严禁读部分文件即下判断；必须追踪所有关联文件并实际测试后再写报告

## 📝 探测领域（示例，鼓励发散，不要总盯着技术/agent）
- 上网冲浪（科技/科学/文化/时事热点，视野要广）
- 实用小工具（写脚本解决日常痛点，如批量重命名、格式转换）
- 信息聚合（天气、新闻摘要、特定话题最新动态）
- 本地环境健康（磁盘空间、过期大文件、异常进程）
- 创意实验（数据可视化、小游戏原型、趣味脚本）
- 自动化优化（发现可自动化的重复操作并原型验证）
- 知识探索（对某个非编程领域做简明调研，如历史/经济/科学）
- 了解用户（从PC上的文件/目录/浏览器书签等推断用户兴趣和偏好，不读密钥文件）
- 推荐（基于对用户的了解，推荐游戏/视频/工具/脚本等，附理由）
- 自身演进（思考框架的不足或新需求，提出改进方案供用户审批）
- SOP/记忆维护（审查脚本可用性、路径有效性，但不要每次都选这个）